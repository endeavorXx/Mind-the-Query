[
  {
    "NL Question": "Retrieve the names of all sources used to post tweets that contain URLs with 'cnn.com' in their expanded_url.",
    "Cypher": "MATCH (t:Tweet)-[:HAS_LINK]->(u:URL) WHERE u.expanded_url CONTAINS 'cnn.com' MATCH (t)-[:POSTED_VIA]->(s:Source) RETURN s.name AS SourceName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 1,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_1",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls whose location is an empty string and who have posted tweets that are retweeted. Return the screen name of the troll and the text of the retweeted tweet.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:RETWEETED]->(rt:Tweet) WHERE t.location = '' RETURN t.screen_name AS TrollScreenName, rt.text AS RetweetedText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 2,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_2",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the count of tweets posted via the source named '<a href=\"http://ifttt.com\" rel=\"nofollow\">IFTTT</a>' that mention a user.",
    "Cypher": "MATCH (t:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://ifttt.com\" rel=\"nofollow\">IFTTT</a>' MATCH (t)-[:MENTIONS]->(u:User) RETURN count(t) AS TweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 3,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_3",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used to post tweets that mention the user with the user_key 'mikandynothem'.",
    "Cypher": "MATCH (t:Tweet)-[:POSTED_VIA]->(s:Source), (t)-[:MENTIONS]->(u:User) WHERE u.user_key = 'mikandynothem' RETURN DISTINCT s.name AS SourceName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 8,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_8",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the names of all trolls who have posted more than one tweet.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet) WITH t, count(tw) AS tweetCount WHERE tweetCount > 1 RETURN t.name AS TrollName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 10,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_10",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that mention both a user and a troll. Return the text of the tweet, the screen name of the mentioned user, and the screen name of the mentioned troll.",
    "Cypher": "MATCH (tw:Tweet)-[:MENTIONS]->(u:User), (tw)-[:MENTIONS]->(t:Troll) RETURN tw.text AS TweetText, u.screen_name AS UserScreenName, t.screen_name AS TrollScreenName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 11,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_11",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used to post tweets that contain the URL 'http://trib.al/z2qiRzX'. Also, return the count of tweets for each source.",
    "Cypher": "MATCH (t:Tweet)-[:HAS_LINK]->(url:URL {expanded_url: 'http://trib.al/z2qiRzX'}), (t)-[:POSTED_VIA]->(s:Source) RETURN s.name AS SourceName, COUNT(t) AS TweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 22,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_22",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that were retweeted. Return the troll's screen name and the text of the original tweet.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:RETWEETED]->(originalTweet:Tweet) RETURN t.screen_name AS TrollScreenName, originalTweet.text AS OriginalTweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 23,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_23",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of all trolls who have posted tweets via the source named '<a href=\"http://dlvr.it\" rel=\"nofollow\">dlvr.it</a>'.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source {name: '<a href=\"http://dlvr.it\" rel=\"nofollow\">dlvr.it</a>'}) RETURN t.name AS TrollName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 25,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_25",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls whose location is 'US' and who have posted tweets that mention users with the screen name 'thebpdshow'. Return the troll's screen name and the text of the tweets.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User) WHERE t.location = 'US' AND u.user_key = 'thebpdshow' RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 30,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_30",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the top 2 hashtags that appear in tweets posted by trolls who have more than 1900 followers. Return the hashtag tag and the number of times it appears in tweets by these trolls.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag) WHERE t.followers_count > 1900 WITH h, COUNT(tw) AS tweetCount ORDER BY tweetCount DESC LIMIT 2 RETURN h.tag AS Hashtag, tweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 31,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_31",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that are posted via '<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>' and retweeted other tweets. Return the tweet id and the id of the retweeted tweet.",
    "Cypher": "MATCH (t:Tweet)-[:POSTED_VIA]->(s:Source), (t)-[:RETWEETED]->(rt:Tweet) WHERE s.name = '<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>' RETURN t.id AS TweetId, rt.id AS RetweetedTweetId",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 32,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_32",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used to post tweets that mention the user with user_key 'brunelldonald'.",
    "Cypher": "MATCH (t:Tweet)-[:MENTIONS]->(u:User), (t)-[:POSTED_VIA]->(s:Source) WHERE u.user_key = 'brunelldonald' RETURN s.name",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 36,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_36",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that are retweets of other tweets and were posted via the source named '<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>'. Return the text of the original tweet being retweeted.",
    "Cypher": "MATCH (t:Tweet)-[:RETWEETED]->(original:Tweet), (t)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>' RETURN original.text",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 37,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_37",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "What are the screen names of trolls who have posted tweets that contain URLs and mention users?",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(u:URL), (tw)-[:MENTIONS]->(user:User) RETURN t.screen_name",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 38,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_38",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that contain both the hashtag 'speechless' and a URL, and return the tweet's text and the expanded URL.",
    "Cypher": "MATCH (t:Tweet)-[:HAS_TAG]->(h:Hashtag), (t)-[:HAS_LINK]->(u:URL) WHERE h.tag = 'speechless' RETURN t.text AS TweetText, u.expanded_url AS ExpandedURL",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 42,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_42",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of all trolls who have posted tweets via the source named '<a href=\"http://twibble.io\" rel=\"nofollow\">Twibble.io</a>', along with the text of those tweets.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://twibble.io\" rel=\"nofollow\">Twibble.io</a>' RETURN t.name AS TrollName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 43,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_43",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that mention both a User and a Troll. Return the text of the tweet, the screen name of the User, and the screen name of the Troll.",
    "Cypher": "MATCH (t:Tweet)-[:MENTIONS]->(u:User), (t)-[:MENTIONS]->(tr:Troll) RETURN t.text AS TweetText, u.screen_name AS UserScreenName, tr.screen_name AS TrollScreenName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 44,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_44",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of all users who have posted tweets that were retweeted, and also include the text of the original tweet that was retweeted.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)-[:RETWEETED]->(ot:Tweet) RETURN u.screen_name AS UserScreenName, ot.text AS OriginalTweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 45,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_45",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the names of all trolls who have posted tweets that contain a URL with 'twitter.com' in the expanded URL and were created before October 1, 2016.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(url:URL) WHERE url.expanded_url CONTAINS 'twitter.com' AND tw.created_at < 1475270400000 RETURN t.name AS TrollName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 46,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_46",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used by trolls with the screen name 'TinaTkurtz1222' to post tweets, along with the text of those tweets.",
    "Cypher": "MATCH (t:Troll {screen_name: 'TinaTkurtz1222'})-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source) RETURN s.name AS SourceName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 50,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_50",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that contain a URL with 'bit.ly' in the expanded URL and were posted before October 11, 2016. Return the troll's name and the tweet's text.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(u:URL) WHERE u.expanded_url CONTAINS 'bit.ly' AND tw.created_at < 1476153600000 RETURN t.name AS TrollName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 52,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_52",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the number of tweets posted by each user, including users and trolls, who have the word 'Trump' in their description. Return the user's name or screen_name, and the count of their tweets, ordered by the count in descending order.",
    "Cypher": "MATCH (p) WHERE (p:User OR p:Troll) AND p.description CONTAINS 'Trump' MATCH (p)-[:POSTED]->(t:Tweet) WITH CASE WHEN p:User THEN p.name ELSE p.screen_name END AS posterName, COUNT(t) AS tweetCount ORDER BY tweetCount DESC RETURN posterName, tweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 53,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_53",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that contain both the hashtag 'veritas' and a URL. Return the troll's screen name and the tweet text.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag), (tw)-[:HAS_LINK]->(u:URL) WHERE h.tag = 'veritas' RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 56,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_56",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used to post tweets that mention the user with user_key 'shanalala_' and also include a URL.",
    "Cypher": "MATCH (s:Source)<-[:POSTED_VIA]-(t:Tweet)-[:MENTIONS]->(u:User), (t)-[:HAS_LINK]->(url:URL) WHERE u.user_key = 'shanalala_' RETURN s.name AS SourceName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 57,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_57",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of trolls who have posted tweets that mention other users and have more than 500 favorites.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User) WHERE tw.favorite_count > 500 RETURN t.screen_name AS TrollScreenName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 59,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_59",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the top 3 users with the most tweets, along with the tweet count and a collection of distinct sources they have used to post tweets.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source) WITH u, COUNT(tw) AS tweetCount, COLLECT(DISTINCT s.name) AS SourcesUsed ORDER BY tweetCount DESC LIMIT 3 RETURN u.user_key AS UserName, tweetCount, SourcesUsed;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 64,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_64",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve all tweets posted by the troll with the screen name 'PaolaKinck' that contain a URL. Return the tweet text and the expanded URL.",
    "Cypher": "MATCH (t:Troll {screen_name: 'PaolaKinck'})-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(url:URL) RETURN tw.text AS TweetText, url.expanded_url AS ExpandedURL;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 65,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_65",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all users who have posted tweets that mention the user with user_key 'motalvanisabela'. Return the names of the users and the text of the tweets they posted.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(m:User {user_key: 'motalvanisabela'}) RETURN u.user_key AS UserKey, tw.text AS TweetText;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 66,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_66",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the number of tweets that contain both the hashtag 'youmightbearacist' and a URL.",
    "Cypher": "MATCH (t:Tweet)-[:HAS_TAG]->(h:Hashtag {tag: 'youmightbearacist'}), (t)-[:HAS_LINK]->(u:URL) RETURN COUNT(t) AS TweetCount;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 67,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_67",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "What are the names of all the sources used to post tweets that are in reply to a tweet with id '760605364333273088'?",
    "Cypher": "MATCH (tw1:Tweet)-[:IN_REPLY_TO]->(tw2:Tweet), (tw1)-[:POSTED_VIA]->(s:Source) WHERE tw2.id = '760605364333273088' RETURN s.name",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 73,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_73",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used to post tweets that contain a URL with 'bit.ly' in the expanded URL.",
    "Cypher": "MATCH (t:Tweet)-[:HAS_LINK]->(url:URL), (t)-[:POSTED_VIA]->(s:Source) WHERE url.expanded_url CONTAINS 'bit.ly' RETURN s.name AS SourceName;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 78,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_78",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the names of trolls who have posted tweets that mention the user with user_key 'shaftan'.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User) WHERE u.user_key = 'shaftan' RETURN t.name AS TrollName;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 79,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_79",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that have at least one hashtag and one URL and were created before October 10, 2016. Return the tweet's ID, text, and the tag of the hashtag.",
    "Cypher": "MATCH (tw:Tweet)-[:HAS_TAG]->(h:Hashtag), (tw)-[:HAS_LINK]->(u:URL) WHERE tw.created_at < 1476067200000 RETURN tw.id AS TweetID, tw.text AS TweetText, h.tag AS Hashtag",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 88,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_88",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the top 3 trolls who have posted the most tweets via the source '<a href=\"http://bufferapp.com\" rel=\"nofollow\">Buffer</a>'. Return the troll's name and the number of tweets they posted via that source.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://bufferapp.com\" rel=\"nofollow\">Buffer</a>' WITH t, COUNT(tw) AS tweetCount ORDER BY tweetCount DESC LIMIT 3 RETURN t.name AS TrollName, tweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 92,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_92",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the top 2 trolls with the most tweets, along with the tweet count and a collection of distinct sources they have used to post tweets.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source) WITH t, COUNT(tw) AS tweetCount, COLLECT(DISTINCT s.name) AS SourcesUsed ORDER BY tweetCount DESC LIMIT 2 RETURN t.name AS TrollName, tweetCount, SourcesUsed;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 99,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_99",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that contain URLs with 'twitter.com' and return the troll's screen name and the expanded URLs.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(url:URL) WHERE url.expanded_url CONTAINS 'twitter.com' RETURN t.screen_name AS TrollScreenName, url.expanded_url AS ExpandedURL;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 100,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_100",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the top 3 users who have posted tweets using the source '<a href=\"http://tapbots.com/tweetbot\" rel=\"nofollow\">Tweetbot for iΟS</a>'. Return the user's name and the number of tweets they posted via that source.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://tapbots.com/tweetbot\" rel=\"nofollow\">Tweetbot for iΟS</a>' WITH u, COUNT(t) AS tweetCount ORDER BY tweetCount DESC LIMIT 3 RETURN u.name AS UserName, tweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 106,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_106",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the screen names of all trolls whose location is 'USA' and who have posted tweets that mention the user with user_key 'wideawake35'.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User) WHERE t.location = 'USA' AND u.user_key = 'wideawake35' RETURN t.screen_name AS TrollScreenName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 107,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_107",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve all tweets that were posted by trolls with a 'Eastern Time (US & Canada)' timezone and contain a URL where the expanded_url contains 'bit.ly'. Return the tweet text and the troll's screen_name.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(url:URL) WHERE t.time_zone = 'Eastern Time (US & Canada)' AND url.expanded_url CONTAINS 'bit.ly' RETURN tw.text AS TweetText, t.screen_name AS TrollScreenName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 108,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_108",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names and follower counts of trolls who have posted tweets via the source '<a href=\"http://dlvr.it\" rel=\"nofollow\">dlvr.it</a>' and have more than 150 followers.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source {name: '<a href=\"http://dlvr.it\" rel=\"nofollow\">dlvr.it</a>'}) WHERE t.followers_count > 150 RETURN t.name AS TrollName, t.followers_count AS Followers;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 113,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_113",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that are retweets of other tweets and also contain a hashtag. Return the ID of the original tweet and the text of the retweet.",
    "Cypher": "MATCH (tw:Tweet)-[:RETWEETED]->(original:Tweet), (tw)-[:HAS_TAG]->(h:Hashtag) RETURN original.id AS OriginalTweetID, tw.text AS RetweetText;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 121,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_121",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of all trolls who have posted tweets that mention a user with the user key 'scrowder' and also contain a URL.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User), (tw)-[:HAS_LINK]->(url:URL) WHERE u.user_key = 'scrowder' RETURN t.screen_name AS TrollScreenName;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 122,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_122",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the names of all sources used to post tweets that contain both the hashtag 'podestaemails30' and mention a user. Return the source name and the number of tweets that satisfy these conditions.",
    "Cypher": "MATCH (tw:Tweet)-[:HAS_TAG]->(h:Hashtag), (tw)-[:MENTIONS]->(u:User), (tw)-[:POSTED_VIA]->(s:Source) WHERE h.tag = 'podestaemails30' WITH s, COUNT(DISTINCT tw) AS TweetCount RETURN s.name AS SourceName, TweetCount;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 123,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_123",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the top 3 sources that have been used to post tweets that mention the user with user_key 'ausoloda'.",
    "Cypher": "MATCH (tw:Tweet)-[:POSTED_VIA]->(s:Source), (tw)-[:MENTIONS]->(u:User) WHERE u.user_key = 'ausoloda' WITH s, COUNT(tw) AS tweetCount ORDER BY tweetCount DESC LIMIT 3 RETURN s.name AS SourceName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 127,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_127",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of all trolls who have posted tweets that mention another user and contain the hashtag 'cbcfalc16'.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User), (tw)-[:HAS_TAG]->(h:Hashtag) WHERE h.tag = 'cbcfalc16' RETURN t.screen_name AS TrollScreenName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 129,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_129",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the number of tweets that mention both a user and a troll. Return the count of such tweets.",
    "Cypher": "MATCH (tw:Tweet)-[:MENTIONS]->(u:User), (tw)-[:MENTIONS]->(t:Troll) RETURN COUNT(DISTINCT tw) AS TweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 130,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_130",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of all trolls who have posted tweets via the source '<a href=\"http://twibble.io\" rel=\"nofollow\">Twibble.io</a>', and return the number of tweets each troll has posted through that source.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://twibble.io\" rel=\"nofollow\">Twibble.io</a>' WITH t.screen_name AS TrollScreenName, COUNT(tw) AS TweetCount RETURN TrollScreenName, TweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 134,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_134",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of trolls whose descriptions contain the word 'news' and who have more than 2000 followers. Return their screen names and follower counts.",
    "Cypher": "MATCH (t:Troll) WHERE t.description CONTAINS 'news' AND t.followers_count > 2000 RETURN t.screen_name AS TrollScreenName, t.followers_count AS FollowerCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 136,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_136",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that are retweets of other tweets and were posted via a source other than '<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>'. Return the text of the retweet and the name of the source it was posted via.",
    "Cypher": "MATCH (t:Tweet)-[:RETWEETED]->(original:Tweet), (t)-[:POSTED_VIA]->(s:Source) WHERE s.name <> '<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>' RETURN t.text AS RetweetText, s.name AS SourceName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 137,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_137",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of trolls who have posted tweets that mention the user with user_key 'youngsinick', and also find the text of those tweets.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User) WHERE u.user_key = 'youngsinick' RETURN t.screen_name, tw.text",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 141,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_141",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that were posted via the source '<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>' and contain the hashtag '5thofnovember'. Return the text of the tweets and their creation timestamps.",
    "Cypher": "MATCH (t:Tweet)-[:POSTED_VIA]->(s:Source), (t)-[:HAS_TAG]->(h:Hashtag) WHERE s.name = '<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>' AND h.tag = '5thofnovember' RETURN t.text, t.created_at",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 142,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_142",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that mention the user with user key 'fungrl1111'. Return the screen name of the troll and the text of the tweet.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User {user_key: 'fungrl1111'}) RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 147,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_147",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of all sources used to post tweets containing the hashtag 'sports'.",
    "Cypher": "MATCH (t:Tweet)-[:HAS_TAG]->(h:Hashtag {tag: 'sports'}), (t)-[:POSTED_VIA]->(s:Source) RETURN DISTINCT s.name AS SourceName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 148,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_148",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "What are the screen names of trolls who have posted tweets that are retweets of tweets with the ID '777717835451682816'?",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:RETWEETED]->(t2:Tweet {id: '777717835451682816'}) RETURN t.screen_name AS TrollScreenName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 150,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_150",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that contain the hashtag 'wearred'. Return the troll's screen name and the text of the tweet.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag) WHERE h.tag = 'wearred' RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 154,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_154",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used to post tweets that contain URLs with 'twitter.com', along with the count of tweets posted via each source.",
    "Cypher": "MATCH (t:Tweet)-[:HAS_LINK]->(url:URL), (t)-[:POSTED_VIA]->(s:Source) WHERE url.expanded_url CONTAINS 'twitter.com' RETURN s.name AS SourceName, COUNT(t) AS TweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 155,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_155",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that mention both a user and a troll. Return the tweet's text, the user's screen name, and the troll's screen name.",
    "Cypher": "MATCH (tw:Tweet)-[:MENTIONS]->(u:User), (tw)-[:MENTIONS]->(t:Troll) RETURN tw.text AS TweetText, u.screen_name AS UserScreenName, t.screen_name AS TrollScreenName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 156,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_156",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of trolls who have posted more than 10000 statuses and have tweets that contain the hashtag 'wearred'.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag) WHERE t.statuses_count > 10000 AND h.tag = 'wearred' RETURN t.screen_name AS TrollScreenName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 157,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_157",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all users who have posted tweets that were posted via '<a href=\"http://tapbots.com/tweetbot\" rel=\"nofollow\">Tweetbot for iΟS</a>'. Return the user's screen name and the text of the tweets.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://tapbots.com/tweetbot\" rel=\"nofollow\">Tweetbot for iΟS</a>' RETURN u.screen_name AS UserScreenName, t.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 158,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_158",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that contain both the hashtag 'neverhillary' and a URL. Return the troll's screen name and the tweet text.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag), (tw)-[:HAS_LINK]->(u:URL) WHERE h.tag = 'neverhillary' RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 161,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_161",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of trolls who have posted more than 5 tweets. Return the troll's screen name and the number of tweets they posted.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet) WITH t, COUNT(tw) AS tweetCount WHERE tweetCount > 5 RETURN t.screen_name AS TrollScreenName, tweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 164,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_164",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used to post tweets that mention the user with user_key 'warfareww'. Also, return the count of such tweets for each source.",
    "Cypher": "MATCH (tw:Tweet)-[:MENTIONS]->(u:User {user_key: 'warfareww'}), (tw)-[:POSTED_VIA]->(s:Source) RETURN s.name AS SourceName, COUNT(tw) AS TweetCount;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 169,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_169",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the names of all trolls who have posted tweets that are retweets of other tweets. Return the troll's name and the text of the original tweet that was retweeted.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:RETWEETED]->(otw:Tweet) RETURN t.name AS TrollName, otw.text AS OriginalTweetText;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 170,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_170",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that both mention a user and contain a URL with 'snappytv.com' in its expanded URL. Return the tweet's text and the screen name of the mentioned user.",
    "Cypher": "MATCH (tw:Tweet)-[:MENTIONS]->(u:User), (tw)-[:HAS_LINK]->(url:URL) WHERE url.expanded_url CONTAINS 'snappytv.com' RETURN tw.text AS TweetText, u.screen_name AS MentionedUserScreenName;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 172,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_172",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used to post tweets that contain URLs with 'politico.com'.",
    "Cypher": "MATCH (t:Tweet)-[:HAS_LINK]->(url:URL) WHERE url.expanded_url CONTAINS 'politico.com' MATCH (t)-[:POSTED_VIA]->(s:Source) RETURN DISTINCT s.name AS SourceName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 176,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_176",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that mention another user. Return the troll's screen name and the name of the mentioned user.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User) RETURN t.screen_name AS TrollScreenName, u.name AS MentionedUserName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 177,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_177",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the text of all tweets that are retweets of other tweets.",
    "Cypher": "MATCH (t:Tweet)-[:RETWEETED]->(original:Tweet) RETURN t.text AS RetweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 178,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_178",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets containing the hashtag 'hillarybashesevangelicals'. Return the troll's screen name and the text of the tweets.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag) WHERE h.tag = 'hillarybashesevangelicals' RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 182,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_182",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used to post tweets that contain URLs with 'twitter.com'. Also, return the count of such tweets for each source.",
    "Cypher": "MATCH (t:Tweet)-[:POSTED_VIA]->(s:Source), (t)-[:HAS_LINK]->(u:URL) WHERE u.expanded_url CONTAINS 'twitter.com' RETURN s.name AS SourceName, COUNT(t) AS TweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 183,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_183",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that mention both the user with user_key 'dinkiedow' and contain a URL. Return the tweet text and the expanded URL.",
    "Cypher": "MATCH (t:Tweet)-[:MENTIONS]->(u:User), (t)-[:HAS_LINK]->(url:URL) WHERE u.user_key = 'dinkiedow' RETURN t.text AS TweetText, url.expanded_url AS ExpandedURL",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 184,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_184",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of trolls who have posted tweets that were created before '2017-03-10 06:45:15' and also contain the hashtag 'hillarybashesevangelicals'.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag) WHERE tw.created_str < '2017-03-10 06:45:15' AND h.tag = 'hillarybashesevangelicals' RETURN t.screen_name AS TrollScreenName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 185,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_185",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of all trolls who have posted tweets that mention the user 'kinmapper'.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User) WHERE u.user_key = 'kinmapper' RETURN t.screen_name",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 190,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_190",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of all trolls who have posted tweets that mention users. Return the troll's screen name and the screen name of the mentioned user.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User) RETURN t.screen_name AS TrollScreenName, u.screen_name AS MentionedUserScreenName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 197,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_197",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "What are the names of the trolls who have posted tweets that are in reply to other tweets? Return the troll's name and the text of the reply tweet.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:IN_REPLY_TO]->(rt:Tweet) RETURN t.name AS TrollName, tw.text AS ReplyTweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 199,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_199",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all users who have posted tweets that mention the user with user_key 'billbellamy'. Return the name of the user who posted the tweet and the text of the tweet.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)-[:MENTIONS]->(m:User) WHERE m.user_key = 'billbellamy' RETURN u.name AS PostingUserName, t.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 200,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_200",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the top 3 trolls with the most tweets that contain URLs, along with the number of tweets and a collection of distinct URLs they have used.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(url:URL) WITH t, COUNT(tw) AS tweetCount, COLLECT(DISTINCT url.expanded_url) AS urls ORDER BY tweetCount DESC LIMIT 3 RETURN t.name AS TrollName, tweetCount, urls;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 204,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_204",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets posted by the troll with the screen name 'claudia42kern' that contain URLs and hashtags. Return the tweet text, the expanded URL, and the hashtag tag.",
    "Cypher": "MATCH (t:Troll {screen_name: 'claudia42kern'})-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(url:URL), (tw)-[:HAS_TAG]->(h:Hashtag) RETURN tw.text AS tweetText, url.expanded_url AS expandedURL, h.tag AS hashtagTag",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 210,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_210",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used to post tweets that mention the user with the user key 'iyad_elbaghdadi'. Also, return the count of tweets for each source.",
    "Cypher": "MATCH (tw:Tweet)-[:MENTIONS]->(u:User {user_key: 'iyad_elbaghdadi'}), (tw)-[:POSTED_VIA]->(s:Source) RETURN s.name AS SourceName, count(tw) AS TweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 211,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_211",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that contain both the hashtag 'palettesofcash' and a URL with 'twitter.com', returning the tweet's text and the expanded URL.",
    "Cypher": "MATCH (t:Tweet)-[:HAS_TAG]->(h:Hashtag), (t)-[:HAS_LINK]->(u:URL) WHERE h.tag = 'palettesofcash' AND u.expanded_url CONTAINS 'twitter.com' RETURN t.text AS TweetText, u.expanded_url AS ExpandedURL",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 217,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_217",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the number of users who have more than 1000 followers and have posted at least one tweet that contains the hashtag 'palettesofcash'.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)-[:HAS_TAG]->(h:Hashtag) WHERE u.followers_count > 1000 AND h.tag = 'palettesofcash' RETURN COUNT(DISTINCT u) AS UserCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 221,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_221",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of trolls who have posted tweets that mention the user with user_key 'mattfinnfnc'.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User) WHERE u.user_key = 'mattfinnfnc' RETURN t.screen_name AS TrollScreenName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 232,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_232",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the text of tweets that retweet other tweets and were posted via '<a href=\"http://twitter.com/download/android\" rel=\"nofollow\">Twitter for Android</a>'.",
    "Cypher": "MATCH (t:Tweet)-[:RETWEETED]->(original:Tweet), (t)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://twitter.com/download/android\" rel=\"nofollow\">Twitter for Android</a>' RETURN t.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 235,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_235",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources that have been used to post tweets that mention the user with user key 'oil_guns_merica'. Also, return the count of tweets posted via each source.",
    "Cypher": "MATCH (tw:Tweet)-[:MENTIONS]->(u:User {user_key: 'oil_guns_merica'}), (tw)-[:POSTED_VIA]->(s:Source) RETURN s.name AS SourceName, COUNT(tw) AS TweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 239,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_239",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that are retweets of other tweets and were posted via the source named '<a href=\"http://bufferapp.com\" rel=\"nofollow\">Buffer</a>'. Return the text of the original tweet and the text of the retweet.",
    "Cypher": "MATCH (tw:Tweet)-[:RETWEETED]->(original:Tweet), (tw)-[:POSTED_VIA]->(s:Source {name: '<a href=\"http://bufferapp.com\" rel=\"nofollow\">Buffer</a>'}) RETURN original.text AS OriginalTweetText, tw.text AS RetweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 240,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_240",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all users who have posted tweets that contain the hashtag 'intellectualtrump'. Return the user's screen name and the text of the tweet.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag {tag: 'intellectualtrump'}) RETURN u.screen_name AS UserScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 242,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_242",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the screen names of trolls who have posted tweets that contain both the hashtag 'maga' and a URL.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag), (tw)-[:HAS_LINK]->(u:URL) WHERE h.tag = 'maga' RETURN t.screen_name AS TrollScreenName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 245,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_245",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used to post tweets that mention the user with the user_key 'seanmdav'.",
    "Cypher": "MATCH (t:Tweet)-[:MENTIONS]->(u:User), (t)-[:POSTED_VIA]->(s:Source) WHERE u.user_key = 'seanmdav' RETURN s.name AS SourceName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 246,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_246",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "What are the names of trolls who have posted tweets that contain the URL 'http://www.politico.com/magazine/story/2016/09/donald-trump-pat-buchanan-republican-america-first-nativist-214221'?",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(u:URL) WHERE u.expanded_url = 'http://www.politico.com/magazine/story/2016/09/donald-trump-pat-buchanan-republican-america-first-nativist-214221' RETURN t.screen_name AS TrollName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 248,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_248",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the tweets that mention a user and are retweets of other tweets. Return the text of the original tweet and the text of the retweet.",
    "Cypher": "MATCH (t:Tweet)-[:MENTIONS]->(u:User), (t)-[:RETWEETED]->(original:Tweet) RETURN original.text AS OriginalTweetText, t.text AS RetweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 249,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_249",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets posted by trolls with the screen name 'CoryNaeNae' that contain URLs and hashtags. Return the tweet text, the expanded URL, and the hashtag.",
    "Cypher": "MATCH (t:Troll {screen_name: 'CoryNaeNae'})-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(url:URL), (tw)-[:HAS_TAG]->(h:Hashtag) RETURN tw.text AS tweetText, url.expanded_url AS expandedURL, h.tag AS hashtag;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 252,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_252",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used to post tweets that mention the user with the user_key 'nataliasdad'. Also, return the text of those tweets.",
    "Cypher": "MATCH (tw:Tweet)-[:MENTIONS]->(u:User {user_key: 'nataliasdad'}), (tw)-[:POSTED_VIA]->(s:Source) RETURN s.name AS SourceName, tw.text AS TweetText;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 253,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_253",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the trolls who have posted tweets that are retweets of other tweets. Return the screen name of the troll and the text of the original tweet that was retweeted.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:RETWEETED]->(originalTweet:Tweet) RETURN t.screen_name AS TrollScreenName, originalTweet.text AS OriginalTweetText;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 254,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_254",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls whose tweets are posted via the source named '<a href=\"http://tweets.add1.ru/add/\" rel=\"nofollow\">pourtwi</a>'. Return the troll's screen name and the text of the tweet.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source {name: '<a href=\"http://tweets.add1.ru/add/\" rel=\"nofollow\">pourtwi</a>'}) RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 256,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_256",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of all sources used to post tweets that contain the URL with 'twitter.com' in its expanded form. Also, return the count of such tweets for each source.",
    "Cypher": "MATCH (t:Tweet)-[:POSTED_VIA]->(s:Source), (t)-[:HAS_LINK]->(u:URL) WHERE u.expanded_url CONTAINS 'twitter.com' RETURN s.name AS SourceName, COUNT(t) AS TweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 260,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_260",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that mention other users. Return the screen name of the troll, the text of the tweet, and the screen name of the mentioned user.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User) RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText, u.screen_name AS MentionedUserScreenName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 261,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_261",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Identify tweets that have been retweeted and also contain the hashtag 'news9'. Return the text of these retweeted tweets and the creation string.",
    "Cypher": "MATCH (t:Tweet)-[:RETWEETED]->(original:Tweet), (t)-[:HAS_TAG]->(h:Hashtag {tag: 'news9'}) RETURN t.text AS TweetText, t.created_str AS CreatedString",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 262,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_262",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find trolls with the location 'USA' who have posted tweets via the source '<a href=\"https://twitter.com/download/android\" rel=\"nofollow\">Twitter for Android Tablets</a>'. Return the screen name of the troll and the text of the tweet.",
    "Cypher": "MATCH (t:Troll {location: 'USA'})-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source {name: '<a href=\"https://twitter.com/download/android\" rel=\"nofollow\">Twitter for Android Tablets</a>'}) RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 263,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_263",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that mention the user with user_key 'hillaryclinton' and also contain the hashtag 'hillaryshealth'. Return the tweet's text and created_at timestamp.",
    "Cypher": "MATCH (t:Tweet)-[:MENTIONS]->(u:User {user_key: 'hillaryclinton'}), (t)-[:HAS_TAG]->(h:Hashtag {tag: 'hillaryshealth'}) RETURN t.text AS TweetText, t.created_at AS TweetCreatedAt;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 266,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_266",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used to post tweets that contain the URL 'http://goo.gl/xrd3mx', along with the text of those tweets.",
    "Cypher": "MATCH (t:Tweet)-[:HAS_LINK]->(u:URL {expanded_url: 'http://goo.gl/xrd3mx'}), (t)-[:POSTED_VIA]->(s:Source) RETURN s.name AS SourceName, t.text AS TweetText;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 267,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_267",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of all users who have been mentioned in tweets posted via '<a href=\"http://www.google.com/\" rel=\"nofollow\">Google</a>'. Also, return the text of those tweets.",
    "Cypher": "MATCH (u:User)<-[:MENTIONS]-(t:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://www.google.com/\" rel=\"nofollow\">Google</a>' RETURN u.name AS UserName, t.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 274,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_274",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find trolls whose location is 'Москва, Россия' and have posted tweets that are retweets. Return the troll's screen name and the retweeted tweet's text.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:RETWEETED]->(rt:Tweet) WHERE t.location = 'Москва, Россия' RETURN t.screen_name AS TrollScreenName, rt.text AS RetweetedText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 275,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_275",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the names of all trolls who have more than 100 followers and have posted tweets containing the URL 'http://bit.ly/2bLuXmv'. Also, return the creation date of their accounts.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(u:URL) WHERE t.followers_count > 100 AND u.expanded_url = 'http://bit.ly/2bLuXmv' RETURN t.name AS TrollName, t.created_at AS AccountCreationDate",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 277,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_277",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the top 3 users who have posted the most tweets via the source named '<a href=\"http://twitter.com/#!/download/ipad\" rel=\"nofollow\">Twitter for iPad</a>'. Also, return the count of tweets posted by each user.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://twitter.com/#!/download/ipad\" rel=\"nofollow\">Twitter for iPad</a>' WITH u, COUNT(t) AS tweetCount ORDER BY tweetCount DESC LIMIT 3 RETURN u.name AS UserName, tweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 281,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_281",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that are retweets of other tweets and also contain a URL with 'washex.am' in its expanded_url. Return the text of the retweet and the expanded_url.",
    "Cypher": "MATCH (t:Tweet)-[:RETWEETED]->(original:Tweet), (t)-[:HAS_LINK]->(u:URL) WHERE u.expanded_url CONTAINS 'washex.am' RETURN t.text AS RetweetText, u.expanded_url AS ExpandedURL",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 282,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_282",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of all trolls who have posted tweets via the source named '<a href=\"http://twitterfeed.com\" rel=\"nofollow\">twitterfeed</a>'. Return the troll's screen_name and the text of the tweet.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source {name: '<a href=\"http://twitterfeed.com\" rel=\"nofollow\">twitterfeed</a>'}) RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 288,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_288",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the tweets that are retweets of other tweets and also contain the URL 'http://j.mp/2fwx6bZ'. Return the id of the retweeted tweet and the text of the original tweet.",
    "Cypher": "MATCH (t:Tweet)-[:RETWEETED]->(original:Tweet), (t)-[:HAS_LINK]->(u:URL {expanded_url: 'http://j.mp/2fwx6bZ'}) RETURN original.id AS OriginalTweetID, original.text AS OriginalTweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 289,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_289",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of all trolls whose tweets have been retweeted, and also find the names of the sources used to post these retweeted tweets. Return the troll's screen name, and a collection of distinct source names.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:RETWEETED]->(retweeted_tweet:Tweet)-[:POSTED_VIA]->(s:Source) WITH t, COLLECT(DISTINCT s.name) AS SourcesUsed RETURN t.screen_name AS TrollScreenName, SourcesUsed",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 291,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_291",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that contain both the hashtag 'tcot' and a URL with 'twitter.com'. Return the tweet's text and the expanded URL.",
    "Cypher": "MATCH (t:Tweet)-[:HAS_TAG]->(h:Hashtag), (t)-[:HAS_LINK]->(u:URL) WHERE h.tag = 'tcot' AND u.expanded_url CONTAINS 'twitter.com' RETURN t.text AS TweetText, u.expanded_url AS ExpandedURL",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 294,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_294",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of all trolls who have posted tweets that mention the user with user_key 'tbm860'. Return the troll's screen name and the text of the tweet.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User) WHERE u.user_key = 'tbm860' RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 295,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_295",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names and locations of trolls who have posted more than 1 tweet. Order the results by the number of tweets posted in descending order.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet) WITH t, COUNT(tw) AS tweetCount WHERE tweetCount > 1 RETURN t.name AS TrollName, t.location AS TrollLocation, tweetCount ORDER BY tweetCount DESC",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 297,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_297",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that contain the hashtag 'cbdoil'. Return the screen name of the troll and the text of the tweet.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag) WHERE h.tag = 'cbdoil' RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 301,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_301",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of all sources used to post tweets that contain a URL with 'ajc.com'. Also, return the tweet id.",
    "Cypher": "MATCH (t:Tweet)-[:HAS_LINK]->(u:URL), (t)-[:POSTED_VIA]->(s:Source) WHERE u.expanded_url CONTAINS 'ajc.com' RETURN s.name AS SourceName, t.id AS TweetID",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 302,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_302",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of all users who posted tweets via the source '<a href=\"http://dlvr.it\" rel=\"nofollow\">dlvr.it</a>' and also return the number of tweets each user posted through that source.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://dlvr.it\" rel=\"nofollow\">dlvr.it</a>' WITH u, COUNT(t) AS tweetCount RETURN u.name AS UserName, tweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 304,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_304",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that mention both a user and a troll. Return the tweet's text, the screen name of the mentioned user, and the screen name of the mentioned troll.",
    "Cypher": "MATCH (t:Tweet)-[:MENTIONS]->(u:User), (t)-[:MENTIONS]->(tr:Troll) RETURN t.text AS TweetText, u.screen_name AS MentionedUser, tr.screen_name AS MentionedTroll",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 308,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_308",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the top 3 users who have posted the most tweets via the source '<a href=\"http://twitter.com/#!/download/ipad\" rel=\"nofollow\">Twitter for iPad</a>'.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://twitter.com/#!/download/ipad\" rel=\"nofollow\">Twitter for iPad</a>' WITH u, COUNT(t) AS tweetCount ORDER BY tweetCount DESC LIMIT 3 RETURN u.name AS UserName, tweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 309,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_309",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of all users who have been mentioned in tweets that contain URLs with 'foxnews.com' in their expanded URL.",
    "Cypher": "MATCH (t:Tweet)-[:HAS_LINK]->(url:URL), (t)-[:MENTIONS]->(u:User) WHERE url.expanded_url CONTAINS 'foxnews.com' RETURN u.screen_name AS MentionedUser",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 311,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_311",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the names of all trolls who have posted tweets that retweeted another tweet. Return the troll's name and the text of the retweeted tweet.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:RETWEETED]->(rt:Tweet) RETURN t.name AS TrollName, rt.text AS RetweetedText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 312,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_312",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the top 3 users who have posted the most tweets via the source '<a href=\"https://twitter.com/download/android\" rel=\"nofollow\">Twitter for Android Tablets</a>'.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"https://twitter.com/download/android\" rel=\"nofollow\">Twitter for Android Tablets</a>' WITH u, COUNT(t) AS tweetCount ORDER BY tweetCount DESC LIMIT 3 RETURN u.name AS UserName, tweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 316,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_316",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "For trolls with the location set to an empty string, find the average number of followers they have, and the number of trolls that fit this criteria.",
    "Cypher": "MATCH (t:Troll) WHERE t.location = '' WITH AVG(t.followers_count) AS avgFollowers, COUNT(t) AS trollCount RETURN avgFollowers, trollCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 318,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_318",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used to post tweets that mention the user with user_key 'worldwidewaco1'. Also, return the count of such tweets for each source.",
    "Cypher": "MATCH (t:Tweet)-[:MENTIONS]->(u:User), (t)-[:POSTED_VIA]->(s:Source) WHERE u.user_key = 'worldwidewaco1' WITH s, COUNT(t) AS tweetCount RETURN s.name AS SourceName, tweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 323,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_323",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets posted by trolls that mention the user with user key 'bet'. Return the troll's screen name, tweet ID and text.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User) WHERE u.user_key = 'bet' RETURN t.screen_name AS trollScreenName, tw.id AS tweetID, tw.text AS tweetText;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 329,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_329",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the names of all trolls who posted tweets that contain URLs with 'bit.ly' in their expanded URL.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(url:URL) WHERE url.expanded_url CONTAINS 'bit.ly' RETURN t.name AS TrollName;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 331,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_331",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of trolls who have posted more than 500 statuses and whose tweets contain URLs with 'twitchy.com'.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(url:URL) WHERE t.statuses_count > 500 AND url.expanded_url CONTAINS 'twitchy.com' RETURN t.screen_name AS TrollScreenName;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 333,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_333",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of trolls who have posted tweets that mention a user and were posted via a source with the name '<a href=\"http://tweets.add1.ru/add/\" rel=\"nofollow\">pourtwi</a>'.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User), (tw)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://tweets.add1.ru/add/\" rel=\"nofollow\">pourtwi</a>' RETURN t.screen_name",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 337,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_337",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "What are the names of the users who are mentioned in tweets posted by the troll 'todayinsyria'?",
    "Cypher": "MATCH (t:Troll {user_key: 'todayinsyria'})-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User) RETURN u.name",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 339,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_339",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of all sources used to post tweets that contain the URL with expanded_url 'http://www.cbsnews.com/news/idk-not-trump-retail-politics-anti-trump-gamble-pays-off-for-urban-outfitters/'.",
    "Cypher": "MATCH (tw:Tweet)-[:HAS_LINK]->(url:URL {expanded_url: 'http://www.cbsnews.com/news/idk-not-trump-retail-politics-anti-trump-gamble-pays-off-for-urban-outfitters/'}), (tw)-[:POSTED_VIA]->(s:Source) RETURN s.name AS SourceName;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 344,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_344",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "What are the names of the sources used to post tweets that mention the troll with the screen name 'Politweecs'?",
    "Cypher": "MATCH (t:Tweet)-[:MENTIONS]->(tr:Troll {screen_name: 'Politweecs'}), (t)-[:POSTED_VIA]->(s:Source) RETURN s.name AS SourceName;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 346,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_346",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the number of tweets posted by users with location 'United States' that contain the hashtag 'dumpsterfire2016'.",
    "Cypher": "MATCH (u:User {location: 'United States'})-[:POSTED]->(t:Tweet)-[:HAS_TAG]->(h:Hashtag {tag: 'dumpsterfire2016'}) RETURN COUNT(t) AS TweetCount;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 347,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_347",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets posted by trolls who have more than 3000 followers and mention a user. Return the troll's screen name, the tweet text, and the screen name of the mentioned user.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User) WHERE t.followers_count > 3000 RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText, u.screen_name AS MentionedUserScreenName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 350,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_350",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used to post tweets that contain URLs with 'cnn.com', along with the number of tweets posted via each source.",
    "Cypher": "MATCH (t:Tweet)-[:POSTED_VIA]->(s:Source), (t)-[:HAS_LINK]->(u:URL) WHERE u.expanded_url CONTAINS 'cnn.com' RETURN s.name AS SourceName, COUNT(t) AS TweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 351,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_351",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the trolls who posted tweets containing the hashtag 'rooseveltshooting'. Return the troll's name and the text of the tweet.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag) WHERE h.tag = 'rooseveltshooting' RETURN t.name AS TrollName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 352,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_352",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all users who have posted tweets that were retweeted, and return the user's screen name and the text of the original tweet.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(tw:Tweet)-[:RETWEETED]->(rt:Tweet) RETURN u.screen_name AS UserScreenName, rt.text AS OriginalTweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 353,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_353",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources that were used to post tweets created before '2017-01-19 00:00:00' and containing URLs. Return the source name and the count of such tweets.",
    "Cypher": "MATCH (t:Tweet)-[:POSTED_VIA]->(s:Source), (t)-[:HAS_LINK]->(u:URL) WHERE t.created_str < '2017-01-19 00:00:00' RETURN s.name AS SourceName, COUNT(t) AS TweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 354,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_354",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the top 3 users who have posted tweets using the source '<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>'. Also, return the number of tweets each user posted via that source.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>' WITH u, COUNT(t) AS tweetCount ORDER BY tweetCount DESC LIMIT 3 RETURN u.name AS UserName, tweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 358,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_358",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that mention the user with user_key 'desdemona4u'. Return the screen name of the troll and the text of the tweet.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User) WHERE u.user_key = 'desdemona4u' RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 359,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_359",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names and follower counts of users who have posted tweets that were retweeted. Also, find the average favorite count of those retweeted tweets.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)-[:RETWEETED]->(rt:Tweet) WITH u, AVG(rt.favorite_count) AS avgFavCount RETURN u.name AS UserName, u.followers_count AS UserFollowers, avgFavCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 360,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_360",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that contain a URL with 'twitter.com' in the expanded URL and whose location is 'USA'. Return the screen names of these trolls.",
    "Cypher": "MATCH (t:Troll {location: 'USA'})-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(u:URL) WHERE u.expanded_url CONTAINS 'twitter.com' RETURN t.screen_name",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 366,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_366",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the text of tweets that are retweets of other tweets and were posted via the source named '<a href=\"http://twitter.com/download/android\" rel=\"nofollow\">Twitter for Android</a>'.",
    "Cypher": "MATCH (t:Tweet)-[:RETWEETED]->(original:Tweet), (t)-[:POSTED_VIA]->(s:Source {name: '<a href=\"http://twitter.com/download/android\" rel=\"nofollow\">Twitter for Android</a>'}) RETURN t.text",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 367,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_367",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used to post tweets that mention the user with user_key 'wikileaks'.",
    "Cypher": "MATCH (t:Tweet)-[:MENTIONS]->(u:User), (t)-[:POSTED_VIA]->(s:Source) WHERE u.user_key = 'wikileaks' RETURN s.name",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 372,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_372",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the screen names of trolls who have posted tweets that contain URLs and were posted via '<a href=\"http://dlvr.it\" rel=\"nofollow\">dlvr.it</a>'.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(u:URL), (tw)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://dlvr.it\" rel=\"nofollow\">dlvr.it</a>' RETURN t.screen_name",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 373,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_373",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the text of tweets that are retweets of tweets mentioning the user with user_key 'wikileaks'.",
    "Cypher": "MATCH (t1:Tweet)-[:RETWEETED]->(t2:Tweet)-[:MENTIONS]->(u:User) WHERE u.user_key = 'wikileaks' RETURN t1.text",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 374,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_374",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used to post tweets that contain the hashtag 'trumpstopwhining'.",
    "Cypher": "MATCH (h:Hashtag {tag: 'trumpstopwhining'})<-[:HAS_TAG]-(t:Tweet)-[:POSTED_VIA]->(s:Source) RETURN DISTINCT s.name AS SourceName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 379,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_379",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find tweets that are retweets of other tweets, and were posted via a source named '<a href=\"http://bufferapp.com\" rel=\"nofollow\">Buffer</a>'. Return the text of the original tweet and the retweet.",
    "Cypher": "MATCH (t:Tweet)-[:RETWEETED]->(original:Tweet), (t)-[:POSTED_VIA]->(s:Source {name: '<a href=\"http://bufferapp.com\" rel=\"nofollow\">Buffer</a>'}) RETURN original.text AS OriginalTweetText, t.text AS RetweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 380,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_380",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "What are the screen names of trolls who have posted tweets that mention a user, and what are the names of those users?",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User) RETURN DISTINCT t.screen_name AS TrollScreenName, u.name AS UserName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 382,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_382",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that contain both the hashtag 'podestaemails10' and a URL. Return the troll's screen name and the text of the tweet.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag), (tw)-[:HAS_LINK]->(u:URL) WHERE h.tag = 'podestaemails10' RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 385,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_385",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that are retweets of other tweets, and also contain the hashtag 'podestaemails10'. Return the original tweet's id and the retweet's id.",
    "Cypher": "MATCH (tw:Tweet)-[:RETWEETED]->(original:Tweet), (tw)-[:HAS_TAG]->(h:Hashtag) WHERE h.tag = 'podestaemails10' RETURN original.id AS OriginalTweetID, tw.id AS RetweetID",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 389,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_389",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the top 3 users who have posted the most tweets via the source '<a href=\"https://medium.com\" rel=\"nofollow\">Medium</a>'. Return each user's name and the number of tweets they posted via that source.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"https://medium.com\" rel=\"nofollow\">Medium</a>' WITH u, COUNT(tw) AS tweetCount ORDER BY tweetCount DESC LIMIT 3 RETURN u.name AS UserName, tweetCount;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 393,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_393",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls whose descriptions contain '#BlackLivesMatter' and who have more than 10000 followers. Return their screen name and follower count.",
    "Cypher": "MATCH (t:Troll) WHERE t.description CONTAINS '#BlackLivesMatter' AND t.followers_count > 10000 RETURN t.screen_name AS trollScreenName, t.followers_count AS followerCount;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 394,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_394",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that mention users with the screen name 'DanaGeezus'. Return the troll's screen name and the text of the tweet.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User) WHERE u.screen_name = 'DanaGeezus' RETURN t.screen_name AS trollScreenName, tw.text AS tweetText;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 396,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_396",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets posted by the troll with user key 'jerstoner' that contain a URL and a hashtag. Return the tweet's text, the expanded URL, and the tag.",
    "Cypher": "MATCH (t:Troll {user_key: 'jerstoner'})-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(url:URL), (tw)-[:HAS_TAG]->(h:Hashtag) RETURN tw.text AS tweetText, url.expanded_url AS expandedURL, h.tag AS hashtag;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 399,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_399",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen name and number of followers for all users who have posted tweets via the source '<a href=\"http://twitterfeed.com\" rel=\"nofollow\">twitterfeed</a>'.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source {name: '<a href=\"http://twitterfeed.com\" rel=\"nofollow\">twitterfeed</a>'}) RETURN u.screen_name AS userScreenName, u.followers_count AS followerCount;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 400,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_400",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "What are the names and locations of trolls who have posted tweets that contain the URL 'https://www.youtube.com/watch?v=-zW66rb4D6I'?",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(url:URL {expanded_url: 'https://www.youtube.com/watch?v=-zW66rb4D6I'}) RETURN t.name AS trollName, t.location AS trollLocation;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 402,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_402",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the text of all tweets that are in reply to a tweet with ID '781825647161245696'.",
    "Cypher": "MATCH (tw:Tweet)-[:IN_REPLY_TO]->(target:Tweet {id: '781825647161245696'}) RETURN tw.text AS tweetText;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 403,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_403",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that mention both a user and a troll, and return the text of the tweet along with the screen names of the mentioned user and troll.",
    "Cypher": "MATCH (t:Tweet)-[:MENTIONS]->(u:User), (t)-[:MENTIONS]->(tr:Troll) RETURN t.text AS TweetText, u.screen_name AS UserScreenName, tr.screen_name AS TrollScreenName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 406,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_406",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources that were used to post tweets containing the hashtag 'maga'. Also, show the count of such tweets for each source.",
    "Cypher": "MATCH (t:Tweet)-[:HAS_TAG]->(h:Hashtag), (t)-[:POSTED_VIA]->(s:Source) WHERE h.tag = 'maga' WITH s.name AS SourceName, COUNT(t) AS TweetCount RETURN SourceName, TweetCount ORDER BY TweetCount DESC",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 407,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_407",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all users who have posted tweets that contain URLs, and return their screen names along with the expanded URLs from their tweets.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)-[:HAS_LINK]->(url:URL) RETURN u.screen_name AS UserScreenName, url.expanded_url AS ExpandedURL",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 408,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_408",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the text of all tweets that are retweets of other tweets, and also return the text of the original tweet.",
    "Cypher": "MATCH (rt:Tweet)-[:RETWEETED]->(ot:Tweet) RETURN rt.text AS RetweetText, ot.text AS OriginalTweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 409,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_409",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find trolls who have posted tweets that mention the user with the user_key 'sheriffclarke', and return the troll's screen name and the text of the tweet.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User) WHERE u.user_key = 'sheriffclarke' RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 410,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_410",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that contain the hashtag '22kill' and return the troll's screen name along with the text of the tweet.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag) WHERE h.tag = '22kill' RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 413,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_413",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of all sources used to post tweets that mention the user with user_key 'ataxia162'.",
    "Cypher": "MATCH (tw:Tweet)-[:MENTIONS]->(u:User), (tw)-[:POSTED_VIA]->(s:Source) WHERE u.user_key = 'ataxia162' RETURN DISTINCT s.name AS SourceName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 414,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_414",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of trolls who have posted tweets that contain both a URL and mention a user. Return the troll's screen name and the expanded URL.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(url:URL), (tw)-[:MENTIONS]->(u:User) RETURN t.screen_name AS TrollScreenName, url.expanded_url AS ExpandedURL",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 416,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_416",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used to post tweets that contain URLs with 'twitter.com' in their expanded_url.",
    "Cypher": "MATCH (t:Tweet)-[:HAS_LINK]->(u:URL) WHERE u.expanded_url CONTAINS 'twitter.com' MATCH (t)-[:POSTED_VIA]->(s:Source) RETURN s.name AS SourceName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 421,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_421",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that mention the user with user_key 'trumphotels'. Return the troll's screen_name and the text of the tweets they posted.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User {user_key: 'trumphotels'}) RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 422,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_422",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls whose description contains the word 'Conservative' and who have posted tweets that contain the URL 'https://twitter.com/FBIMostWanted/status/777835873953996801'. Return the troll's name and the content of the matching tweets.",
    "Cypher": "MATCH (t:Troll) WHERE t.description CONTAINS 'Conservative' MATCH (t)-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(u:URL {expanded_url: 'https://twitter.com/FBIMostWanted/status/777835873953996801'}) RETURN t.name AS TrollName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 424,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_424",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "What are the names and follower counts of users who have posted tweets that contain the URL 'http://bit.ly/2epczQZ' and have more than 500 followers?",
    "Cypher": "MATCH (u:User)-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(url:URL) WHERE url.expanded_url = 'http://bit.ly/2epczQZ' AND u.followers_count > 500 RETURN u.name AS UserName, u.followers_count AS UserFollowers",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 428,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_428",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the names of all sources used to post tweets that mention the user with user_key 'pawpagerald12'.",
    "Cypher": "MATCH (tw:Tweet)-[:MENTIONS]->(u:User), (tw)-[:POSTED_VIA]->(s:Source) WHERE u.user_key = 'pawpagerald12' RETURN DISTINCT s.name AS SourceName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 429,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_429",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets posted by the troll with user_key 'bigseanbeast' that mention another user. Return the text of the tweet and the screen name of the mentioned user.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User) WHERE t.user_key = 'bigseanbeast' RETURN tw.text AS TweetText, u.screen_name AS MentionedUserScreenName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 431,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_431",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources that were used to post tweets that mention the user with user_key 'heytana'. Also, return the count of such tweets for each source.",
    "Cypher": "MATCH (tw:Tweet)-[:MENTIONS]->(u:User), (tw)-[:POSTED_VIA]->(s:Source) WHERE u.user_key = 'heytana' WITH s, COUNT(tw) AS tweetCount RETURN s.name AS SourceName, tweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 435,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_435",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted more than 5 tweets and whose tweets contain the hashtag 'morgen'. Return the troll's name and the number of tweets they posted with that hashtag.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag) WHERE h.tag = 'morgen' WITH t, COUNT(tw) AS tweetCount WHERE tweetCount > 5 RETURN t.name AS TrollName, tweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 436,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_436",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that are retweets of other tweets and also contain a URL with 'mediaite.com'. Return the text of the original tweet and the text of the retweet.",
    "Cypher": "MATCH (tw:Tweet)-[:RETWEETED]->(original:Tweet), (tw)-[:HAS_LINK]->(url:URL) WHERE url.expanded_url CONTAINS 'mediaite.com' RETURN original.text AS OriginalTweetText, tw.text AS RetweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 438,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_438",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used to post tweets that mention the user with user_key 'explorer68841'.",
    "Cypher": "MATCH (t:Tweet)-[:MENTIONS]->(u:User), (t)-[:POSTED_VIA]->(s:Source) WHERE u.user_key = 'explorer68841' RETURN DISTINCT s.name AS SourceName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 442,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_442",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the trolls who have posted more than one tweet, and for each such troll, return their screen name and the count of tweets they have posted.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet) WITH t, COUNT(tw) AS tweetCount WHERE tweetCount > 1 RETURN t.screen_name AS TrollScreenName, tweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 443,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_443",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the text of all tweets that are retweets of other tweets and were posted via the source named '<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>'.",
    "Cypher": "MATCH (t:Tweet)-[:RETWEETED]->(original:Tweet), (t)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>' RETURN t.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 444,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_444",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that were retweeted, and return the troll's screen name along with the text of the original tweet.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:RETWEETED]->(originalTweet:Tweet) RETURN t.screen_name AS TrollScreenName, originalTweet.text AS OriginalTweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 450,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_450",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of all users who have been mentioned in tweets that also contain a URL with 'dailycaller.com'.",
    "Cypher": "MATCH (t:Tweet)-[:MENTIONS]->(u:User), (t)-[:HAS_LINK]->(url:URL) WHERE url.expanded_url CONTAINS 'dailycaller.com' RETURN u.screen_name AS MentionedUser",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 451,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_451",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets posted via sources with names containing 'Medium' that also have a favorite_count greater than 0, and return the tweet text and the source name.",
    "Cypher": "MATCH (t:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name CONTAINS 'Medium' AND t.favorite_count > 0 RETURN t.text AS TweetText, s.name AS SourceName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 452,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_452",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of trolls who have posted tweets that contain the URL 'http://hill.cm/ONIp3TH'. Also, return the text of those tweets.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(url:URL {expanded_url: 'http://hill.cm/ONIp3TH'}) RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 456,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_456",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the number of tweets that both mention a user with user key 'anthonyeinzig' and contain the hashtag 'thevoice'.",
    "Cypher": "MATCH (t:Tweet)-[:MENTIONS]->(u:User {user_key: 'anthonyeinzig'}), (t)-[:HAS_TAG]->(h:Hashtag {tag: 'thevoice'}) RETURN count(t) AS TweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 459,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_459",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that contain the hashtag 'alicia'. Return the screen name of the troll and the text of the tweet.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag) WHERE h.tag = 'alicia' RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 462,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_462",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of all sources used to post tweets that mention the user with the user key 'creatvemonster'.",
    "Cypher": "MATCH (tw:Tweet)-[:MENTIONS]->(u:User) WHERE u.user_key = 'creatvemonster' MATCH (tw)-[:POSTED_VIA]->(s:Source) RETURN s.name AS SourceName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 463,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_463",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls located in 'USA' who have posted tweets that contain URLs with 'twitter.com' in their expanded URL. Return the troll's screen name and the tweet's text.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(url:URL) WHERE t.location = 'USA' AND url.expanded_url CONTAINS 'twitter.com' RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 464,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_464",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the trolls who have posted the most number of tweets. Return the troll's screen name and the count of tweets they have posted, limiting the result to the top 3 trolls.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet) WITH t, COUNT(tw) AS TweetCount ORDER BY TweetCount DESC LIMIT 3 RETURN t.screen_name AS TrollScreenName, TweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 466,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_466",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of sources that were used to post tweets which mention the user with user_key 'keitholbermann'. Also, return the count of such tweets for each source.",
    "Cypher": "MATCH (s:Source)<-[:POSTED_VIA]-(t:Tweet)-[:MENTIONS]->(u:User) WHERE u.user_key = 'keitholbermann' WITH s, COUNT(t) AS tweetCount RETURN s.name AS SourceName, tweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 470,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_470",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the trolls who have posted tweets that are in reply to other tweets. Return the screen name of the troll and the text of the tweet they posted.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:IN_REPLY_TO]->(tw2:Tweet) RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 471,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_471",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of trolls who have more than 500 followers and have posted tweets via sources whose names contain 'Twitter'.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source) WHERE t.followers_count > 500 AND s.name CONTAINS 'Twitter' RETURN t.screen_name AS TrollScreenName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 472,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_472",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that contain both a URL and mention a user. Return the tweet's text, the expanded URL, and the mentioned user's screen name.",
    "Cypher": "MATCH (tw:Tweet)-[:HAS_LINK]->(u:URL), (tw)-[:MENTIONS]->(user:User) RETURN tw.text AS TweetText, u.expanded_url AS ExpandedURL, user.screen_name AS MentionedUser",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 473,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_473",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of trolls who have posted tweets that are in reply to another tweet. Return the troll's screen name and the ID of the tweet they replied to.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:IN_REPLY_TO]->(reply_tw:Tweet) RETURN t.screen_name AS TrollScreenName, tw.id AS TweetID;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 479,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_479",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the names of users who have posted tweets via '<a href=\"http://tapbots.com/tweetbot\" rel=\"nofollow\">Tweetbot for iΟS</a>' and have more than 500 followers.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://tapbots.com/tweetbot\" rel=\"nofollow\">Tweetbot for iΟS</a>' AND u.followers_count > 500 RETURN u.name",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 483,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_483",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that were retweeted, and return their screen names along with the text of the original tweets that were retweeted.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:RETWEETED]->(originalTweet:Tweet) RETURN t.screen_name, originalTweet.text",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 487,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_487",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of all users who have been mentioned in tweets that were retweeted, and also find the text of those retweeted tweets.",
    "Cypher": "MATCH (u:User)<-[:MENTIONS]-(t:Tweet)-[:RETWEETED]->(rt:Tweet) RETURN u.name, rt.text",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 491,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_491",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the names of all sources used to post tweets that mention the user with user_key '__sheisfierce'.",
    "Cypher": "MATCH (t:Tweet)-[:MENTIONS]->(u:User), (t)-[:POSTED_VIA]->(s:Source) WHERE u.user_key = '__sheisfierce' RETURN s.name",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 492,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_492",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the text of all tweets posted by the troll with the screen name 'heyits_toby' that also contain a URL.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(u:URL) WHERE t.screen_name = 'heyits_toby' RETURN tw.text",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 493,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_493",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used by trolls whose location is 'USA' to post tweets, along with the count of tweets posted via each source.",
    "Cypher": "MATCH (t:Troll {location: 'USA'})-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source) RETURN s.name AS SourceName, COUNT(tw) AS TweetCount ORDER BY TweetCount DESC",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 498,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_498",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that contain URLs with 'bit.ly' and also mention a user. Return the troll's screen name and the expanded URLs.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(url:URL), (tw)-[:MENTIONS]->(u:User) WHERE url.expanded_url CONTAINS 'bit.ly' RETURN t.screen_name AS TrollScreenName, url.expanded_url AS ExpandedURL",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 499,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_499",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls with a time zone of 'Pacific Time (US & Canada)' who have posted tweets that are in reply to other tweets. Return the troll's name and the text of the reply tweet.",
    "Cypher": "MATCH (t:Troll {time_zone: 'Pacific Time (US & Canada)'})-[:POSTED]->(tw:Tweet)-[:IN_REPLY_TO]->(original:Tweet) RETURN t.name AS TrollName, tw.text AS ReplyTweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 501,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_501",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find users who have posted tweets that mention the user with user_key 'lynnlonbeck' and return the number of tweets they posted.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)-[:MENTIONS]->(m:User) WHERE m.user_key = 'lynnlonbeck' WITH u, COUNT(t) AS tweetCount RETURN u.user_key, tweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 506,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_506",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the text of tweets that are retweets of tweets mentioning the user with user_key 'hillaryclinton'.",
    "Cypher": "MATCH (t:Tweet)-[:RETWEETED]->(t2:Tweet)-[:MENTIONS]->(u:User) WHERE u.user_key = 'hillaryclinton' RETURN t.text",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 507,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_507",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted more than one tweet that contains the hashtag 'demdebatemiami'. Return their screen names.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag) WHERE h.tag = 'demdebatemiami' WITH t, COUNT(tw) AS tweetCount WHERE tweetCount > 1 RETURN t.screen_name",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 508,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_508",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of all sources used to post tweets that contain URLs with 'cbslocal.com'. Also, return the count of such tweets for each source.",
    "Cypher": "MATCH (t:Tweet)-[:HAS_LINK]->(url:URL) WHERE url.expanded_url CONTAINS 'cbslocal.com' MATCH (t)-[:POSTED_VIA]->(s:Source) RETURN s.name AS SourceName, COUNT(t) AS TweetCount;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 512,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_512",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of trolls who have posted tweets that mention the user with the user_key 'samgriot'. Return the troll's screen name and the text of the tweet.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User {user_key: 'samgriot'}) RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 514,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_514",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the text of tweets posted by trolls located in 'Москва' that also contain a hashtag.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag) WHERE t.location = 'Москва' RETURN tw.text",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 521,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_521",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the names of users who have posted tweets using the source '<a href=\"http://bufferapp.com\" rel=\"nofollow\">Buffer</a>' and have more than 500 statuses.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://bufferapp.com\" rel=\"nofollow\">Buffer</a>' AND u.statuses_count > 500 RETURN u.name",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 522,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_522",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets posted by the troll with the ID '4272870988' that contain a hashtag and return the tweet's text and the hashtag's tag.",
    "Cypher": "MATCH (t:Troll {id: '4272870988'})-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag) RETURN tw.text AS TweetText, h.tag AS Hashtag;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 525,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_525",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen name of the user who posted the tweet with ID '796047328914407424'.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet {id: '796047328914407424'}) RETURN u.screen_name AS UserScreenName;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 526,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_526",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of all sources used to post tweets that contain the hashtag 'twisters'.",
    "Cypher": "MATCH (t:Tweet)-[:HAS_TAG]->(h:Hashtag {tag: 'twisters'}), (t)-[:POSTED_VIA]->(s:Source) RETURN DISTINCT s.name AS SourceName;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 528,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_528",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all users who have posted tweets that have been retweeted, and return the user's screen name along with the text of the original and retweeted tweets.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t1:Tweet)-[:RETWEETED]->(t2:Tweet) RETURN u.screen_name AS UserScreenName, t1.text AS OriginalTweet, t2.text AS RetweetedTweet",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 534,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_534",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of trolls who have posted tweets that contain URLs with 'twitter.com' in their expanded URL, and also return the text of those tweets.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(url:URL) WHERE url.expanded_url CONTAINS 'twitter.com' RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 535,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_535",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find users who have posted more than 2 tweets and have 'en' as their language, return their screen name and the count of tweets they posted.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet) WHERE u.lang = 'en' WITH u, COUNT(t) AS tweetCount WHERE tweetCount > 2 RETURN u.screen_name AS UserScreenName, tweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 536,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_536",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Identify all tweets that mention both a user and a troll. Return the text of the tweet, the screen name of the mentioned user, and the screen name of the mentioned troll.",
    "Cypher": "MATCH (t:Tweet)-[:MENTIONS]->(u:User), (t)-[:MENTIONS]->(tr:Troll) RETURN t.text AS TweetText, u.screen_name AS UserScreenName, tr.screen_name AS TrollScreenName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 542,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_542",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls located in 'Pittsburgh, US' who have posted tweets that are in reply to another tweet. Return the screen name of the troll and the text of their tweet.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:IN_REPLY_TO]->(rt:Tweet) WHERE t.location = 'Pittsburgh, US' RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 543,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_543",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that contain both the hashtag 'bombshell' and a URL, and return the troll's screen name and the text of the tweet.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag), (tw)-[:HAS_LINK]->(u:URL) WHERE h.tag = 'bombshell' RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 546,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_546",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used to post tweets that mention the user with user_key 'karensvest', along with the count of tweets posted via each source.",
    "Cypher": "MATCH (t:Tweet)-[:MENTIONS]->(u:User), (t)-[:POSTED_VIA]->(s:Source) WHERE u.user_key = 'karensvest' RETURN s.name AS SourceName, COUNT(t) AS TweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 547,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_547",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of trolls who have posted tweets that contain the URL 'http://observer.com/2016/09/howard-deans-unhinged-unfounded-accusation-of-cocaine-abuse-only-helps-donald-trump/#.V-0uiKMCjTg.twitter' and whose location is 'USA'.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(u:URL) WHERE t.location = 'USA' AND u.expanded_url = 'http://observer.com/2016/09/howard-deans-unhinged-unfounded-accusation-of-cocaine-abuse-only-helps-donald-trump/#.V-0uiKMCjTg.twitter' RETURN t.screen_name AS TrollScreenName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 549,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_549",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the tweets that mention both a user and a troll, and return the tweet's text, the user's screen name, and the troll's screen name.",
    "Cypher": "MATCH (t:Tweet)-[:MENTIONS]->(u:User), (t)-[:MENTIONS]->(tr:Troll) RETURN t.text AS TweetText, u.screen_name AS UserScreenName, tr.screen_name AS TrollScreenName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_1_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 550,
    "unique_id": "twitter_trolls_data_3_1_2_6_Complex_Retrieval_550",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that contain both the hashtag 'bobama' and a URL, returning the troll's screen name and the tweet text.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag), (tw)-[:HAS_LINK]->(u:URL) WHERE h.tag = 'bobama' RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 0,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_0",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used to post tweets that mention users with the user key 'therickydavila', along with the count of tweets posted via each source.",
    "Cypher": "MATCH (tw:Tweet)-[:MENTIONS]->(u:User), (tw)-[:POSTED_VIA]->(s:Source) WHERE u.user_key = 'therickydavila' WITH s.name AS SourceName, COUNT(tw) AS TweetCount RETURN SourceName, TweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 1,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_1",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of all trolls who have posted tweets that mention other trolls, and whose tweets have a retweet count greater than 0.",
    "Cypher": "MATCH (t1:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(t2:Troll) WHERE tw.retweet_count > 0 RETURN t1.name AS TrollName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 3,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_3",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of all trolls whose tweets mention both the user 'mailonline' and contain a URL. Return the troll's name and the expanded URL.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User), (tw)-[:HAS_LINK]->(url:URL) WHERE u.user_key = 'mailonline' RETURN t.name, url.expanded_url",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 10,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_10",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of trolls who have posted tweets that mention both a user with the user_key 'hrhidaho' and contain a URL.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User), (tw)-[:HAS_LINK]->(url:URL) WHERE u.user_key = 'hrhidaho' RETURN t.screen_name AS TrollScreenName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 17,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_17",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who posted tweets that contain both the hashtag 'secede' and a URL. Return the troll's screen name, the tweet text, and the expanded URL.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag), (tw)-[:HAS_LINK]->(u:URL) WHERE h.tag = 'secede' RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText, u.expanded_url AS ExpandedURL",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 21,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_21",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of all trolls who have posted tweets that contain URLs with 'usatoday.com' in their expanded URL and whose location is not an empty string.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(u:URL) WHERE u.expanded_url CONTAINS 'usatoday.com' AND t.location <> '' RETURN t.screen_name AS TrollScreenName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 24,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_24",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets containing URLs that include 'bit.ly'. Return the troll's screen name and the tweet text.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(url:URL) WHERE url.expanded_url CONTAINS 'bit.ly' RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 28,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_28",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used to post tweets that contain the hashtag 'krieg'. Also, return the count of tweets posted via each source.",
    "Cypher": "MATCH (h:Hashtag {tag: 'krieg'})<-[:HAS_TAG]-(t:Tweet)-[:POSTED_VIA]->(s:Source) RETURN s.name AS SourceName, COUNT(t) AS TweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 29,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_29",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the text of all tweets that retweeted the tweet with ID '781455820013928449'.",
    "Cypher": "MATCH (t1:Tweet {id: '781455820013928449'})<-[:RETWEETED]-(t2:Tweet) RETURN t2.text AS RetweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 31,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_31",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that mention the user with user_key 'capemaymeg'. Return the troll's screen name and the text of the tweet.",
    "Cypher": "MATCH (u:User {user_key: 'capemaymeg'})<-[:MENTIONS]-(t:Tweet)<-[:POSTED]-(tr:Troll) RETURN tr.screen_name AS TrollScreenName, t.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 32,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_32",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the screen names of trolls who have posted tweets that mention the user with user_key 'corporatocrazy'. Also, return the text of those tweets.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User {user_key: 'corporatocrazy'}) RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 37,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_37",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the top 3 users who have posted tweets via the source '<a href=\"http://bufferapp.com\" rel=\"nofollow\">Buffer</a>'. Return each user's name and the count of tweets they posted via this source.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://bufferapp.com\" rel=\"nofollow\">Buffer</a>' WITH u, COUNT(t) AS tweetCount ORDER BY tweetCount DESC LIMIT 3 RETURN u.name AS UserName, tweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 43,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_43",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that mention the user with user_key 'aaronblake'. Return the troll's screen name, the tweet's text, and the creation date of the tweet.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User) WHERE u.user_key = 'aaronblake' RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText, tw.created_str AS TweetCreationDate",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 44,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_44",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen name and location of trolls who have posted tweets via the source named '<a href=\"http://ifttt.com\" rel=\"nofollow\">IFTTT</a>'.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://ifttt.com\" rel=\"nofollow\">IFTTT</a>' RETURN t.screen_name AS TrollScreenName, t.location AS TrollLocation",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 50,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_50",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find users who have been mentioned in tweets that also contain the hashtag '#TrumpTrain'. Return the user's screen name and the text of the tweet.",
    "Cypher": "MATCH (t:Tweet)-[:MENTIONS]->(u:User) MATCH (t)-[:HAS_TAG]->(h:Hashtag) WHERE h.tag = 'trumptrain' RETURN u.screen_name AS UserScreenName, t.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 51,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_51",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets retweeted from the tweet with id '788748468617482240' and posted via the source '<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>'. Return the text of the retweet and the created_str of the retweet.",
    "Cypher": "MATCH (t:Tweet)-[:RETWEETED]->(original:Tweet), (t)-[:POSTED_VIA]->(s:Source) WHERE original.id = '788748468617482240' AND s.name = '<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>' RETURN t.text AS RetweetText, t.created_str AS RetweetCreatedStr",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 53,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_53",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names and follower counts of users who have posted tweets via the source '<a href=\"http://novapress.net.ru/\" rel=\"nofollow\">NovaPress Publisher</a>' and have more than 1000 followers.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://novapress.net.ru/\" rel=\"nofollow\">NovaPress Publisher</a>' AND u.followers_count > 1000 RETURN u.name AS UserName, u.followers_count AS Followers",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 57,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_57",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all users who have been mentioned in tweets that were posted via the source '<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>'. Return the user's name and the text of the mentioning tweets.",
    "Cypher": "MATCH (tw:Tweet)-[:MENTIONS]->(u:User), (tw)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>' RETURN u.name AS UserName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 60,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_60",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that contain both the hashtag 'debatenight' and a URL. Return the screen name of the troll and the text of the tweet.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag), (tw)-[:HAS_LINK]->(u:URL) WHERE h.tag = 'debatenight' RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 63,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_63",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the top 3 sources used to post tweets that mention the user with user_key 'solutioneer72'.",
    "Cypher": "MATCH (t:Tweet)-[:MENTIONS]->(u:User), (t)-[:POSTED_VIA]->(s:Source) WHERE u.user_key = 'solutioneer72' RETURN s.name AS SourceName, COUNT(t) AS TweetCount ORDER BY TweetCount DESC LIMIT 3",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 64,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_64",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of all trolls who have posted more than 1000 statuses and have the location 'USA'.",
    "Cypher": "MATCH (t:Troll) WHERE t.statuses_count > 1000 AND t.location = 'USA' RETURN t.name AS TrollName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 66,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_66",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that retweeted other tweets, and were posted via '<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>'. Return the original tweet's text and the retweet's text.",
    "Cypher": "MATCH (t:Tweet)-[:RETWEETED]->(original:Tweet) MATCH (t)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>' RETURN original.text AS OriginalTweetText, t.text AS RetweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 73,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_73",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of all users who have posted more than one tweet, and at least one of these tweets contains the hashtag 'mypreworkoutroutine'.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)-[:HAS_TAG]->(h:Hashtag) WHERE h.tag = 'mypreworkoutroutine' WITH u, COUNT(t) AS tweetCount WHERE tweetCount > 1 RETURN u.name AS UserName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 74,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_74",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of all trolls who are located in 'Amerika' and have posted more than 10 tweets.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet) WHERE t.location = 'Amerika' WITH t, COUNT(tw) AS TweetCount WHERE TweetCount > 10 RETURN t.screen_name AS TrollScreenName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 80,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_80",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that mention both the user with user_key 'basedmattforney' and contain a URL that includes 'twitter.com'. Return the tweet's text and the expanded URL.",
    "Cypher": "MATCH (t:Tweet)-[:MENTIONS]->(u:User), (t)-[:HAS_LINK]->(url:URL) WHERE u.user_key = 'basedmattforney' AND url.expanded_url CONTAINS 'twitter.com' RETURN t.text AS TweetText, url.expanded_url AS ExpandedURL",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 81,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_81",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the top 3 users who have posted the most tweets via the source '<a href=\"http://tweets.add1.ru/add/\" rel=\"nofollow\">pourtwi</a>'. Return the user's name and the number of tweets they posted using that source.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://tweets.add1.ru/add/\" rel=\"nofollow\">pourtwi</a>' WITH u, COUNT(t) AS tweetCount ORDER BY tweetCount DESC LIMIT 3 RETURN u.name AS UserName, tweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 85,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_85",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of trolls who have posted tweets that contain the hashtag 'illuminate' and whose location is 'USA'.",
    "Cypher": "MATCH (t:Troll {location: 'USA'})-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag) WHERE h.tag = 'illuminate' RETURN t.screen_name AS TrollScreenName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 87,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_87",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that are retweets of other tweets and also contain a URL. Return the ID of the original tweet and the ID of the retweet.",
    "Cypher": "MATCH (t:Tweet)-[:RETWEETED]->(original:Tweet), (t)-[:HAS_LINK]->(u:URL) RETURN original.id AS OriginalTweetID, t.id AS RetweetID",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 88,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_88",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the average favorite_count of tweets posted by trolls whose location is an empty string ('') and who have more than 3000 followers.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet) WHERE t.location = '' AND t.followers_count > 3000 RETURN avg(tw.favorite_count) AS AverageFavoriteCount;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 94,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_94",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that are retweets of other tweets, and were posted via a source other than '<a href=\"http://ifttt.com\" rel=\"nofollow\">IFTTT</a>'. Return the text of the retweet and the name of the source it was posted via.",
    "Cypher": "MATCH (tw:Tweet)-[:RETWEETED]->(original:Tweet), (tw)-[:POSTED_VIA]->(s:Source) WHERE s.name <> '<a href=\"http://ifttt.com\" rel=\"nofollow\">IFTTT</a>' RETURN tw.text AS RetweetText, s.name AS SourceName;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 95,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_95",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used by users with 'BlacklivesMatter' in their description to post tweets, along with the count of tweets posted from each source by these users.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)-[:POSTED_VIA]->(s:Source) WHERE u.description CONTAINS '#BlacklivesMatter' RETURN s.name AS SourceName, COUNT(t) AS TweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 99,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_99",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the number of tweets posted by trolls with the language set to 'ru' (Russian) that also contain a hashtag.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag) WHERE t.lang = 'ru' RETURN count(tw)",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 102,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_102",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the top 3 sources used to post tweets that contain URLs with 'cnn.com' in their expanded URL. Return the source name and the number of tweets posted through that source.",
    "Cypher": "MATCH (t:Tweet)-[:POSTED_VIA]->(s:Source), (t)-[:HAS_LINK]->(u:URL) WHERE u.expanded_url CONTAINS 'cnn.com' WITH s.name AS sourceName, COUNT(t) AS tweetCount ORDER BY tweetCount DESC LIMIT 3 RETURN sourceName, tweetCount;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 106,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_106",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have more than 1000 followers and have posted tweets that mention the user with user_key 'mikepencevp'. Return the troll's screen name, follower count, and the text of the tweets they posted.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User) WHERE t.followers_count > 1000 AND u.user_key = 'mikepencevp' RETURN t.screen_name AS trollScreenName, t.followers_count AS followerCount, tw.text AS tweetText;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 107,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_107",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the average number of followers of users who have posted tweets via the source '<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>'.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>' RETURN avg(u.followers_count) AS averageFollowers;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 109,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_109",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources that have been used to post tweets that mention the user with user_key 'maryneilson1'. Also, return the count of tweets posted via each source.",
    "Cypher": "MATCH (t:Tweet)-[:MENTIONS]->(u:User), (t)-[:POSTED_VIA]->(s:Source) WHERE u.user_key = 'maryneilson1' WITH s, COUNT(t) AS tweetCount RETURN s.name AS SourceName, tweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 113,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_113",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of trolls who have posted tweets that contain the URL 'http://therightscoop.com/curt-schilling-outrages-every-journalist-tweeting-trump-shirt/'.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(url:URL) WHERE url.expanded_url = 'http://therightscoop.com/curt-schilling-outrages-every-journalist-tweeting-trump-shirt/' RETURN t.screen_name AS TrollScreenName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 115,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_115",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used to post tweets that mention the user with the user_key 'gloed_up'.",
    "Cypher": "MATCH (s:Source)<-[:POSTED_VIA]-(t:Tweet)-[:MENTIONS]->(u:User) WHERE u.user_key = 'gloed_up' RETURN s.name",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 120,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_120",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the tweets that have been retweeted more than 20 times and contain a URL with 'bit.ly'. Return the tweet text and the retweet count.",
    "Cypher": "MATCH (t:Tweet)-[:HAS_LINK]->(u:URL) WHERE t.retweet_count > 20 AND u.expanded_url CONTAINS 'bit.ly' RETURN t.text, t.retweet_count",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 121,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_121",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "What are the names of the trolls who posted tweets using the source '<a href=\"https://medium.com\" rel=\"nofollow\">Medium</a>'?",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"https://medium.com\" rel=\"nofollow\">Medium</a>' RETURN t.name",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 122,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_122",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used to post tweets that mention the user with user_key 'johnfugelsang', along with the count of such tweets for each source.",
    "Cypher": "MATCH (tw:Tweet)-[:MENTIONS]->(u:User), (tw)-[:POSTED_VIA]->(s:Source) WHERE u.user_key = 'johnfugelsang' WITH s.name AS SourceName, COUNT(DISTINCT tw) AS TweetCount RETURN SourceName, TweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 127,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_127",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of trolls who have posted more than one tweet, and the text of those tweets.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet) WITH t, COLLECT(tw.text) AS TweetTexts WHERE size(TweetTexts) > 1 RETURN t.screen_name AS TrollScreenName, TweetTexts",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 129,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_129",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that are retweets of other tweets, and also contain the hashtag 'ohvotesearly'. Return the text and retweet_count of these tweets.",
    "Cypher": "MATCH (tw:Tweet)-[:RETWEETED]->(original:Tweet), (tw)-[:HAS_TAG]->(h:Hashtag) WHERE h.tag = 'ohvotesearly' RETURN tw.text AS TweetText, tw.retweet_count AS RetweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 135,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_135",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used to post tweets that mention the user with user_key 'joyannreid'. Also, return the count of tweets posted via each source.",
    "Cypher": "MATCH (t:Tweet)-[:MENTIONS]->(u:User), (t)-[:POSTED_VIA]->(s:Source) WHERE u.user_key = 'joyannreid' RETURN s.name AS SourceName, COUNT(t) AS TweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 141,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_141",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that are retweets of other tweets, and were posted via the source with name '<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>'. Return the text of the original tweet and the text of the retweet.",
    "Cypher": "MATCH (t1:Tweet)-[:RETWEETED]->(t2:Tweet), (t1)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>' RETURN t1.text AS RetweetText, t2.text AS OriginalTweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 142,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_142",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources that were used to post tweets that mention the user with user key 'maxblumenthal'. Also, return the count of such tweets for each source.",
    "Cypher": "MATCH (tw:Tweet)-[:MENTIONS]->(u:User), (tw)-[:POSTED_VIA]->(s:Source) WHERE u.user_key = 'maxblumenthal' WITH s.name AS SourceName, tw RETURN SourceName, count(tw) as TweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 148,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_148",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that were posted by trolls and retweeted other tweets. Return the troll's screen name and the text of the original and retweeted tweets.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:RETWEETED]->(otw:Tweet) RETURN t.screen_name AS TrollScreenName, tw.text AS RetweetedText, otw.text AS OriginalTweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 149,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_149",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the text of tweets that contain a URL and were posted via the source named '<a href=\"http://twitterfeed.com\" rel=\"nofollow\">twitterfeed</a>'.",
    "Cypher": "MATCH (tw:Tweet)-[:HAS_LINK]->(u:URL), (tw)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://twitterfeed.com\" rel=\"nofollow\">twitterfeed</a>' RETURN tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 150,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_150",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the top 3 users who have posted tweets via the source '<a href=\"http://twitter.com/#!/download/ipad\" rel=\"nofollow\">Twitter for iPad</a>', ordered by the number of tweets they posted through that source.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://twitter.com/#!/download/ipad\" rel=\"nofollow\">Twitter for iPad</a>' WITH u, COUNT(t) AS tweetCount ORDER BY tweetCount DESC LIMIT 3 RETURN u.name AS UserName, tweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 155,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_155",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the average number of followers of trolls who have posted at least 5 tweets.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet) WITH t, COUNT(tw) AS tweetCount WHERE tweetCount >= 5 RETURN avg(t.followers_count) AS AverageFollowers",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 157,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_157",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets posted by the troll with user key 'adrienne_gg' that contain both a hashtag and a URL. Return the tweet's text, the hashtag's tag, and the URL's expanded URL.",
    "Cypher": "MATCH (t:Troll {user_key: 'adrienne_gg'})-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag), (tw)-[:HAS_LINK]->(u:URL) RETURN tw.text AS tweetText, h.tag AS hashtag, u.expanded_url AS url;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 161,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_161",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used to post tweets that mention the user with user key 'bcayberg', along with the count of tweets posted via each source.",
    "Cypher": "MATCH (tw:Tweet)-[:MENTIONS]->(u:User {user_key: 'bcayberg'}), (tw)-[:POSTED_VIA]->(s:Source) RETURN s.name AS SourceName, COUNT(tw) AS TweetCount;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 162,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_162",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls whose tweets are retweeted. Return the screen name of the troll and the text of the original tweet.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)<-[:RETWEETED]-(retweet:Tweet) RETURN t.screen_name AS TrollScreenName, tw.text AS OriginalTweetText;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 163,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_163",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find trolls who have posted tweets containing URLs with 'newsbbc.net' in their expanded URL and whose location is 'USA'. Return the troll's screen name and the expanded URL.",
    "Cypher": "MATCH (t:Troll {location: 'USA'})-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(u:URL) WHERE u.expanded_url CONTAINS 'newsbbc.net' RETURN t.screen_name AS TrollScreenName, u.expanded_url AS ExpandedURL;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 165,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_165",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the top 3 users with the highest number of tweets that have been posted via '<a href=\"http://twibble.io\" rel=\"nofollow\">Twibble.io</a>'. Return their screen names and the tweet count.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://twibble.io\" rel=\"nofollow\">Twibble.io</a>' WITH u, COUNT(tw) AS TweetCount ORDER BY TweetCount DESC LIMIT 3 RETURN u.screen_name AS UserScreenName, TweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 171,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_171",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that contain both the hashtag 'elites' and a URL, and return the text of those tweets along with the expanded URL.",
    "Cypher": "MATCH (t:Tweet)-[:HAS_TAG]->(h:Hashtag), (t)-[:HAS_LINK]->(u:URL) WHERE h.tag = 'elites' RETURN t.text AS TweetText, u.expanded_url AS ExpandedURL",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 175,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_175",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of trolls who have posted tweets via the source '<a href=\"http://twitter.com/download/android\" rel=\"nofollow\">Twitter for Android</a>', along with the text of those tweets.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://twitter.com/download/android\" rel=\"nofollow\">Twitter for Android</a>' RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 176,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_176",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find users who have been mentioned in tweets that also contain the hashtag 'elites'. Return the names of these users along with the text of the tweets.",
    "Cypher": "MATCH (t:Tweet)-[:MENTIONS]->(u:User), (t)-[:HAS_TAG]->(h:Hashtag) WHERE h.tag = 'elites' RETURN u.name AS UserName, t.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 177,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_177",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of trolls who have posted tweets that are retweets of other tweets. Return the troll's name and the text of the original tweet that was retweeted.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:RETWEETED]->(originalTweet:Tweet) RETURN t.name AS TrollName, originalTweet.text AS OriginalTweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 178,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_178",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that are retweets of other tweets and also contain the hashtag '#news'. Return the ID of the original tweet and the text of the retweet.",
    "Cypher": "MATCH (t1:Tweet)-[:RETWEETED]->(t2:Tweet), (t1)-[:HAS_TAG]->(h:Hashtag) WHERE h.tag = 'news' RETURN t2.id AS OriginalTweetID, t1.text AS RetweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 184,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_184",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the tweets that were posted by users with more than 1000 followers and that have been retweeted at least once. Return the text of those tweets and the screen names of the users who posted them.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet) WHERE u.followers_count > 1000 AND t.retweet_count > 0 RETURN t.text AS TweetText, u.screen_name AS UserScreenName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 186,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_186",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that mention the user with the user_key 'claricehd47'. Return the troll's screen name and the text of the tweets they posted that mention this user.",
    "Cypher": "MATCH (tr:Troll)-[:POSTED]->(t:Tweet)-[:MENTIONS]->(u:User) WHERE u.user_key = 'claricehd47' RETURN tr.screen_name AS TrollScreenName, t.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 191,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_191",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of sources used to post tweets that mention the user with user_key 'realdonaldtrump'. Also, return the count of tweets posted via each source.",
    "Cypher": "MATCH (t:Tweet)-[:MENTIONS]->(u:User), (t)-[:POSTED_VIA]->(s:Source) WHERE u.user_key = 'realdonaldtrump' WITH s.name AS SourceName, COUNT(t) AS TweetCount RETURN SourceName, TweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 197,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_197",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that are retweets of other tweets, and which also contain the hashtag 'trump'. Return the id of the original tweet and the text of the retweet.",
    "Cypher": "MATCH (t1:Tweet)-[:RETWEETED]->(t2:Tweet), (t1)-[:HAS_TAG]->(h:Hashtag) WHERE h.tag = 'trump' RETURN t2.id AS OriginalTweetId, t1.text AS RetweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 198,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_198",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of trolls who have posted tweets in reply to the tweet with ID '762675570937298944', and also retrieve the text of those tweets.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:IN_REPLY_TO]->(tw2:Tweet) WHERE tw2.id = '762675570937298944' RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 199,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_199",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of all users who have posted tweets via the source '<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>' and have more than 1000 followers.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>' AND u.followers_count > 1000 RETURN u.screen_name AS UserScreenName;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 204,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_204",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the names of all trolls who have posted tweets that mention the user with user_key 'bostonfortrump'.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User) WHERE u.user_key = 'bostonfortrump' RETURN t.name AS TrollName;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 205,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_205",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the text of all tweets that are retweets of the tweet with ID '777916560187002880'.",
    "Cypher": "MATCH (t:Tweet)-[:RETWEETED]->(original:Tweet) WHERE original.id = '777916560187002880' RETURN t.text AS RetweetText;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 206,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_206",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used to post tweets that mention the user with user_key 'carrieksada'. Also, return the count of such tweets for each source.",
    "Cypher": "MATCH (tw:Tweet)-[:MENTIONS]->(u:User), (tw)-[:POSTED_VIA]->(s:Source) WHERE u.user_key = 'carrieksada' WITH s.name AS SourceName, COUNT(tw) AS TweetCount RETURN SourceName, TweetCount;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 211,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_211",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of trolls whose tweets have been posted via the source with the name '<a href=\"http://www.google.com/\" rel=\"nofollow\">Google</a>'. Also, return the text of these tweets.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://www.google.com/\" rel=\"nofollow\">Google</a>' RETURN t.name AS TrollName, tw.text AS TweetText;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 213,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_213",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of trolls who have posted tweets that mention the user with user_key 'jmktv'. Also, return the text of those tweets.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User) WHERE u.user_key = 'jmktv' RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 218,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_218",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all users who have been mentioned in tweets that also contain the hashtag 'mondaynightfootball'. Return the user's screen name and the number of tweets in which they were mentioned alongside the hashtag.",
    "Cypher": "MATCH (u:User)<-[:MENTIONS]-(t:Tweet)-[:HAS_TAG]->(h:Hashtag) WHERE h.tag = 'mondaynightfootball' WITH u, COUNT(DISTINCT t) AS TweetCount RETURN u.screen_name AS UserScreenName, TweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 221,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_221",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the text of all tweets that retweet another tweet and were posted via '<a href=\"http://twitter.com/#!/download/ipad\" rel=\"nofollow\">Twitter for iPad</a>'.",
    "Cypher": "MATCH (tw:Tweet)-[:RETWEETED]->(rt:Tweet), (tw)-[:POSTED_VIA]->(s:Source {name: '<a href=\"http://twitter.com/#!/download/ipad\" rel=\"nofollow\">Twitter for iPad</a>'}) RETURN tw.text AS TweetText;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 227,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_227",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the top 3 users who have posted tweets via the most distinct sources. Return the user's name and the count of distinct sources they used.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source) WITH u, COUNT(DISTINCT s.name) AS distinctSources ORDER BY distinctSources DESC LIMIT 3 RETURN u.name AS UserName, distinctSources AS NumberOfDistinctSources",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 232,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_232",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that mention both a user and a troll, and return the tweet's ID, the screen name of the mentioned user, and the screen name of the mentioned troll.",
    "Cypher": "MATCH (t:Tweet)-[:MENTIONS]->(u:User), (t)-[:MENTIONS]->(tr:Troll) RETURN t.id AS TweetID, u.screen_name AS MentionedUser, tr.screen_name AS MentionedTroll",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 233,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_233",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names and follower counts of all users who have posted tweets that contain URLs with 'youtube.com' and also have more than 1000 followers.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)-[:HAS_LINK]->(url:URL) WHERE url.expanded_url CONTAINS 'youtube.com' AND u.followers_count > 1000 RETURN u.screen_name AS UserScreenName, u.followers_count AS Followers",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 234,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_234",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the names of all sources that have been used to post tweets that retweeted other tweets, and return the source names along with the count of such tweets posted via each source.",
    "Cypher": "MATCH (t:Tweet)-[:POSTED_VIA]->(s:Source) , (t)-[:RETWEETED]->(t2:Tweet) RETURN s.name AS SourceName, count(t) as TweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 235,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_235",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that mention the user with user_key 'pascorevolution'. Return the troll's screen name and the text of the tweet.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User) WHERE u.user_key = 'pascorevolution' RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 240,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_240",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the number of tweets posted by users with the language set to 'en' (English) that contain URLs. Also, return the number of users.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)-[:HAS_LINK]->(url:URL) WHERE u.lang = 'en' WITH COUNT(DISTINCT t) AS TweetCount, COUNT(DISTINCT u) AS UserCount RETURN TweetCount, UserCount;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 241,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_241",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used to post tweets that mention the user with user_key 'geffgefferson1'. Also, return the count of tweets posted via each source.",
    "Cypher": "MATCH (t:Tweet)-[:MENTIONS]->(u:User), (t)-[:POSTED_VIA]->(s:Source) WHERE u.user_key = 'geffgefferson1' RETURN s.name AS SourceName, COUNT(t) AS TweetCount;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 246,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_246",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that are retweets of tweets with id '788622162190041088' and were posted via the source named '<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>'. Return the text of the original tweet and the text of the retweet.",
    "Cypher": "MATCH (t1:Tweet)<-[:RETWEETED]-(t2:Tweet)-[:POSTED_VIA]->(s:Source) WHERE t1.id = '788622162190041088' AND s.name = '<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>' RETURN t1.text AS OriginalTweetText, t2.text AS RetweetText;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 247,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_247",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the top 3 users who have posted tweets via '<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>', along with the count of tweets they posted through this source and their average favorite count on those tweets.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>' WITH u, COUNT(tw) AS tweetCount, AVG(tw.favorite_count) AS avgFavoriteCount ORDER BY tweetCount DESC LIMIT 3 RETURN u.name AS UserName, tweetCount, avgFavoriteCount;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 253,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_253",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of all trolls who have posted more than 1000 statuses and whose tweets have been retweeted at least once.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet) WHERE t.statuses_count > 1000 AND tw.retweet_count > 0 RETURN t.screen_name AS TrollScreenName;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 255,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_255",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the names and locations of trolls who have posted tweets via the source named '<a href=\"http://novapress.net.ru/\" rel=\"nofollow\">NovaPress Publisher</a>'.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://novapress.net.ru/\" rel=\"nofollow\">NovaPress Publisher</a>' RETURN t.name, t.location",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 262,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_262",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the top 3 users who have posted tweets via the most distinct sources. Return each user's name, the count of distinct sources, and a collection of the source names.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source) WITH u, COUNT(DISTINCT s.name) AS sourceCount, COLLECT(DISTINCT s.name) AS sourceNames ORDER BY sourceCount DESC LIMIT 3 RETURN u.name AS userName, sourceCount, sourceNames;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 274,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_274",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names and follower counts of users who have posted tweets that contain URLs with 'sptnkne.ws' and have more than 500 followers.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(url:URL) WHERE url.expanded_url CONTAINS 'sptnkne.ws' AND u.followers_count > 500 RETURN u.name AS userName, u.followers_count AS userFollowers;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 276,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_276",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names and locations of trolls who have posted tweets via the source '<a href=\"https://medium.com\" rel=\"nofollow\">Medium</a>'.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"https://medium.com\" rel=\"nofollow\">Medium</a>' RETURN t.name AS TrollName, t.location AS TrollLocation;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 281,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_281",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the number of tweets posted by trolls whose location is 'Калининград, Россия' that also contain a URL.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(u:URL) WHERE t.location = 'Калининград, Россия' RETURN count(tw) AS TweetCount;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 284,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_284",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the top 3 users who have posted tweets via the same source as the tweet with ID '793484112501682176'.",
    "Cypher": "MATCH (t:Tweet {id: '793484112501682176'})-[:POSTED_VIA]->(s:Source) WITH s MATCH (u:User)-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s) RETURN u.name LIMIT 3",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 288,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_288",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that are retweets of other tweets, and which also contain a URL. Return the ID of the retweet and the expanded URL.",
    "Cypher": "MATCH (tw:Tweet)-[:RETWEETED]->(original:Tweet), (tw)-[:HAS_LINK]->(url:URL) RETURN tw.id AS RetweetID, url.expanded_url AS ExpandedURL",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 291,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_291",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the top 3 users who have posted the most tweets via the source '<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>'. Also return the number of tweets they posted through this source.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>' WITH u, COUNT(t) AS tweetCount ORDER BY tweetCount DESC LIMIT 3 RETURN u.name AS UserName, tweetCount;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 295,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_295",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve all trolls whose description contains the word 'Patriot' and have posted at least 10000 statuses. Return their screen name and statuses count.",
    "Cypher": "MATCH (t:Troll) WHERE t.description CONTAINS 'Patriot' AND t.statuses_count >= 10000 RETURN t.screen_name AS trollScreenName, t.statuses_count AS statusesCount;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 297,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_297",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls whose location is 'United States' and who have posted tweets that contain the hashtag '#news'. Return the troll's screen name and the text of the tweets.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag) WHERE t.location = 'United States' AND h.tag = 'news' RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 303,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_303",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of trolls who have posted tweets that are retweets of other tweets. Also, return the text of the original tweet that was retweeted.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:RETWEETED]->(originalTweet:Tweet) RETURN t.screen_name AS TrollScreenName, originalTweet.text AS OriginalTweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 304,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_304",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find users who have been mentioned in tweets that also contain the hashtag 'usa'. Return the user's name and the text of the tweets in which they were mentioned.",
    "Cypher": "MATCH (t:Tweet)-[:MENTIONS]->(u:User) MATCH (t)-[:HAS_TAG]->(h:Hashtag) WHERE h.tag = 'usa' RETURN u.name AS UserName, t.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 305,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_305",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who posted tweets that contain both a hashtag and a URL. Return the troll's screen name, the tweet's text, the hashtag's tag, and the URL's expanded URL.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag), (tw)-[:HAS_LINK]->(u:URL) RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText, h.tag AS Hashtag, u.expanded_url AS URL;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 308,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_308",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of trolls who have posted tweets that contain a URL with 'breitbart.com' in the expanded_url and were created before '2016-09-19'. Return the troll's screen name and the tweet's creation string.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(u:URL) WHERE u.expanded_url CONTAINS 'breitbart.com' AND tw.created_str < '2016-09-19' RETURN t.screen_name AS TrollScreenName, tw.created_str AS TweetCreationString;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 311,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_311",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all users who have posted more than 2 tweets that mention another user. Return the user's name and the number of tweets where they mention another user.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(m:User) WHERE u <> m WITH u, COUNT(DISTINCT tw) AS MentionedTweetCount WHERE MentionedTweetCount > 2 RETURN u.name AS UserName, MentionedTweetCount;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 312,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_312",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets posted by trolls whose location is 'ATL' that contain URLs. Return the troll's screen name, the tweet ID, and the expanded URL.",
    "Cypher": "MATCH (t:Troll {location: 'ATL'})-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(url:URL) RETURN t.screen_name AS trollScreenName, tw.id AS tweetID, url.expanded_url AS expandedURL;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 315,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_315",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the top 3 users who have posted tweets via the most distinct sources. Return the user's name and the count of distinct sources used.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source) WITH u, COUNT(DISTINCT s.name) AS distinctSourceCount ORDER BY distinctSourceCount DESC LIMIT 3 RETURN u.name AS UserName, distinctSourceCount;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 316,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_316",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of all trolls who have posted tweets that mention a user with the user_key 'shooters_wife'.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User {user_key: 'shooters_wife'}) RETURN t.screen_name AS trollScreenName;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 318,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_318",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the tweets that were posted via a source with the name '<a href=\"http://dlvr.it\" rel=\"nofollow\">dlvr.it</a>' and also contain a hashtag. Return the tweet's text and the tag of the hashtag.",
    "Cypher": "MATCH (t:Tweet)-[:POSTED_VIA]->(s:Source {name: '<a href=\"http://dlvr.it\" rel=\"nofollow\">dlvr.it</a>'}), (t)-[:HAS_TAG]->(h:Hashtag) RETURN t.text AS tweetText, h.tag AS hashtag;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 319,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_319",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that are retweets of other tweets and were posted via the source named '<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>'. Return the id and text of these retweeted tweets.",
    "Cypher": "MATCH (t:Tweet)-[:RETWEETED]->(original:Tweet), (t)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>' RETURN t.id, t.text",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 324,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_324",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of all trolls whose tweets mention the user with the user_key 'mitchellvii' and also contain a URL with 'bit.ly' in it.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User), (tw)-[:HAS_LINK]->(url:URL) WHERE u.user_key = 'mitchellvii' AND url.expanded_url CONTAINS 'bit.ly' RETURN t.name",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 325,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_325",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names and locations of all trolls who have posted more than 100 tweets and whose descriptions are not empty.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet) WITH t, COUNT(tw) AS TweetCount WHERE TweetCount > 100 AND t.description <> '' RETURN t.screen_name AS TrollScreenName, t.location AS TrollLocation;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 332,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_332",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that have both the hashtag 'tcot' and a URL containing 'ow.ly'. Return the tweet's text and the expanded URL.",
    "Cypher": "MATCH (t:Tweet)-[:HAS_TAG]->(h:Hashtag) WHERE h.tag = 'tcot' MATCH (t)-[:HAS_LINK]->(u:URL) WHERE u.expanded_url CONTAINS 'ow.ly' RETURN t.text AS TweetText, u.expanded_url AS ExpandedURL;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 343,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_343",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used to post tweets that mention the user with user_key 'alexkollet'. Also, return the count of tweets posted via each source.",
    "Cypher": "MATCH (t:Tweet)-[:MENTIONS]->(u:User) WHERE u.user_key = 'alexkollet' MATCH (t)-[:POSTED_VIA]->(s:Source) RETURN s.name AS SourceName, COUNT(t) AS TweetCount;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 344,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_344",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of users who have posted tweets that were retweeted from the tweet with ID '800716024370855937'.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)-[:RETWEETED]->(t2:Tweet) WHERE t2.id = '800716024370855937' RETURN u.screen_name AS UserScreenName;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 346,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_346",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of all trolls whose tweets mention users who have more than 19000 followers.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User) WHERE u.followers_count > 19000 RETURN t.screen_name",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 353,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_353",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that contain both a URL and a hashtag. Return the troll's screen name, the tweet's text, and the hashtag's tag.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(url:URL), (tw)-[:HAS_TAG]->(h:Hashtag) RETURN t.screen_name AS trollScreenName, tw.text AS tweetText, h.tag AS hashtagTag",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 357,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_357",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the top 3 users who have posted the most tweets via the source '<a href=\"http://twitter.com/download/android\" rel=\"nofollow\">Twitter for Android</a>'. Return each user's screen name and the number of tweets they posted using that source.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://twitter.com/download/android\" rel=\"nofollow\">Twitter for Android</a>' WITH u, COUNT(tw) AS tweetCount ORDER BY tweetCount DESC LIMIT 3 RETURN u.screen_name AS userScreenName, tweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 358,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_358",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names and follower counts of all trolls who have posted tweets that contain the hashtag 'whymydaddyleft' and have more than 2000 followers.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag) WHERE h.tag = 'whymydaddyleft' AND t.followers_count > 2000 RETURN t.name AS trollName, t.followers_count AS trollFollowers",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 360,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_360",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets posted by trolls located in 'Cincinnati, OH' that contain URLs and hashtags. Return the troll's screen name, the tweet's text, and the expanded URLs.",
    "Cypher": "MATCH (t:Troll {location: 'Cincinnati, OH'})-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(url:URL), (tw)-[:HAS_TAG]->(h:Hashtag) RETURN t.screen_name AS trollScreenName, tw.text AS tweetText, url.expanded_url AS expandedURL",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 371,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_371",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the top 3 users who have posted tweets via the same source '<a href=\"http://twitterfeed.com\" rel=\"nofollow\">twitterfeed</a>'. Return the user's name and the count of tweets posted via that source.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)-[:POSTED_VIA]->(s:Source {name: '<a href=\"http://twitterfeed.com\" rel=\"nofollow\">twitterfeed</a>'}) WITH u, COUNT(t) AS tweetCount ORDER BY tweetCount DESC LIMIT 3 RETURN u.name AS UserName, tweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 372,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_372",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls whose descriptions contain the word 'news' and who have posted tweets that contain the hashtag 'news'. Return the troll's screen name and the text of the tweets.",
    "Cypher": "MATCH (t:Troll) WHERE t.description CONTAINS 'news' MATCH (t)-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag {tag: 'news'}) RETURN t.screen_name AS trollScreenName, tw.text AS tweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 373,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_373",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of all trolls who have posted more than 10000 statuses and have fewer than 10000 followers. Also retrieve the text of one of their tweets.",
    "Cypher": "MATCH (t:Troll) WHERE t.statuses_count > 10000 AND t.followers_count < 10000 MATCH (t)-[:POSTED]->(tw:Tweet) WITH t, collect(tw.text)[0] as tweetText RETURN t.screen_name AS trollScreenName, tweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 374,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_374",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that contain both a hashtag and a URL. Return the troll's screen name, the tweet's text, the hashtag's tag, and the URL's expanded URL.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag), (tw)-[:HAS_LINK]->(u:URL) RETURN t.screen_name AS trollScreenName, tw.text AS tweetText, h.tag AS hashtag, u.expanded_url AS url;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 378,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_378",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of all sources used to post tweets that contain URLs with 'bit.ly'. Also, return the number of tweets posted from each source.",
    "Cypher": "MATCH (t:Tweet)-[:POSTED_VIA]->(s:Source), (t)-[:HAS_LINK]->(u:URL) WHERE u.expanded_url CONTAINS 'bit.ly' WITH s, COUNT(t) AS tweetCount RETURN s.name AS SourceName, tweetCount;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 381,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_381",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that are in reply to other tweets. Return the troll's screen name, the text of their tweet, and the ID of the tweet they replied to.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:IN_REPLY_TO]->(reply_tw:Tweet) RETURN t.screen_name AS trollScreenName, tw.text AS tweetText, reply_tw.id AS repliedToTweetId;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 382,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_382",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of trolls who have posted tweets that mention the user with the user_key 'stillnoregrets1'. Also, return the text of those tweets.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User {user_key: 'stillnoregrets1'}) RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 386,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_386",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all users who have posted tweets that contain the hashtag 'hrcoriginalbirther' and also contain a URL. Return the user's screen name and the expanded URL.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)-[:HAS_TAG]->(h:Hashtag {tag: 'hrcoriginalbirther'}), (t)-[:HAS_LINK]->(url:URL) RETURN u.screen_name AS UserScreenName, url.expanded_url AS ExpandedURL",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 389,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_389",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets containing the hashtag 'clintoncrimefamily' and return the troll's screen name, the tweet's text, and the creation date of the tweet.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag) WHERE h.tag = 'clintoncrimefamily' RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText, tw.created_str AS TweetCreationDate;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 392,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_392",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used to post tweets that contain URLs with 'nydn.us' in their expanded URL, along with the count of tweets posted via each source.",
    "Cypher": "MATCH (t:Tweet)-[:POSTED_VIA]->(s:Source), (t)-[:HAS_LINK]->(u:URL) WHERE u.expanded_url CONTAINS 'nydn.us' RETURN s.name AS SourceName, COUNT(t) AS TweetCount;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 393,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_393",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets posted by the troll with the user key 'gvardeykalena' that also contain a URL. Return the tweet's text and the expanded URL.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(u:URL) WHERE t.user_key = 'gvardeykalena' RETURN tw.text AS TweetText, u.expanded_url AS ExpandedURL;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 396,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_396",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the top 3 users who have posted the most tweets via the source '<a href=\"http://tweets.add1.ru/add/\" rel=\"nofollow\">pourtwi</a>'. Return the user's name and the number of tweets they posted using this source.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://tweets.add1.ru/add/\" rel=\"nofollow\">pourtwi</a>' WITH u, COUNT(tw) AS tweetCount ORDER BY tweetCount DESC LIMIT 3 RETURN u.name AS UserName, tweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 400,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_400",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all users who have posted more than 10 tweets and have at least one tweet containing the URL 'http://bit.ly/2cjhncR'. Return the user's name and the number of tweets they have posted.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(tw:Tweet) WITH u, COUNT(tw) AS tweetCount WHERE tweetCount > 10 MATCH (u)-[:POSTED]->(t:Tweet)-[:HAS_LINK]->(url:URL) WHERE url.expanded_url = 'http://bit.ly/2cjhncR' RETURN u.name AS UserName, tweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 403,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_403",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used to post tweets that mention the user with user_key 'betseyross'. Also, return the count of tweets posted via each source.",
    "Cypher": "MATCH (t:Tweet)-[:MENTIONS]->(u:User), (t)-[:POSTED_VIA]->(s:Source) WHERE u.user_key = 'betseyross' RETURN s.name AS SourceName, COUNT(t) AS TweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 407,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_407",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of trolls who have posted more than 100 statuses and whose tweets mention users who have more than 1000 followers. Return the troll's name and the number of users with over 1000 followers they mention.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User) WHERE t.statuses_count > 100 AND u.followers_count > 1000 RETURN t.name AS TrollName, COUNT(DISTINCT u) AS CountOfUsersWithHighFollowers",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 409,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_409",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of trolls who have posted tweets via the source '<a href=\"http://bufferapp.com\" rel=\"nofollow\">Buffer</a>' and who have more than 2000 followers.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://bufferapp.com\" rel=\"nofollow\">Buffer</a>' AND t.followers_count > 2000 RETURN t.screen_name;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 421,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_421",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that contain both the hashtag 'potcallingkettleblack' and a URL. Return the troll's screen name and the text of the tweet.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag), (tw)-[:HAS_LINK]->(u:URL) WHERE h.tag = 'potcallingkettleblack' RETURN t.screen_name AS trollScreenName, tw.text AS tweetText;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 427,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_427",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the top 3 users who have posted the most tweets via the source named '<a href=\"http://tweets.add1.ru/add/\" rel=\"nofollow\">pourtwi</a>'. Return the user's name and the number of tweets they posted from that source.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://tweets.add1.ru/add/\" rel=\"nofollow\">pourtwi</a>' WITH u, COUNT(t) AS tweetCount ORDER BY tweetCount DESC LIMIT 3 RETURN u.name AS UserName, tweetCount;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 428,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_428",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls whose description contains the word 'Anthropology' and who have posted tweets via a source whose name contains the word 'Twitter'. Return the troll's screen name and the tweet's text.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source) WHERE t.description CONTAINS 'Anthropology' AND s.name CONTAINS 'Twitter' RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 431,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_431",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the top 3 users who have posted tweets via the same source as the tweet with ID '787814906867359744'. Include the number of tweets each user has posted via that source.",
    "Cypher": "MATCH (t:Tweet {id: '787814906867359744'})-[:POSTED_VIA]->(s:Source)<-[:POSTED_VIA]-(tw:Tweet)<-[:POSTED]-(u:User) WITH u, s, COUNT(tw) AS tweetCount ORDER BY tweetCount DESC LIMIT 3 RETURN u.name AS UserName, tweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 435,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_435",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of all users who have posted tweets that contain URLs and also mention other users. Return the name of the user who posted the tweet, the expanded URL, and the screen name of the mentioned user.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(url:URL), (tw)-[:MENTIONS]->(m:User) RETURN u.name AS PosterName, url.expanded_url AS ExpandedURL, m.screen_name AS MentionedUserScreenName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 437,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_437",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of all users who have posted tweets via the source '<a href=\"https://medium.com\" rel=\"nofollow\">Medium</a>' and have also been mentioned in other tweets.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"https://medium.com\" rel=\"nofollow\">Medium</a>' MATCH (t:Tweet)-[:MENTIONS]->(u) RETURN u.name",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 442,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_442",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all users whose tweets have been retweeted, and who have more than 1000 followers. Return the screen name of the user and the text of their original tweet.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)<-[:RETWEETED]-(:Tweet) WHERE u.followers_count > 1000 RETURN u.screen_name, t.text",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 445,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_445",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that contain both a hashtag and a URL. Return the troll's screen name, the tweet's text, and the expanded URL.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag), (tw)-[:HAS_LINK]->(u:URL) RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText, u.expanded_url AS ExpandedURL",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 448,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_448",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the top 3 users who have posted the most tweets via the same source, along with the source name and the count of tweets.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)-[:POSTED_VIA]->(s:Source) WITH u, s, COUNT(t) AS tweetCount ORDER BY tweetCount DESC LIMIT 3 RETURN u.name AS UserName, s.name AS SourceName, tweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 449,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_449",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that mention both a user and a troll. Return the tweet's text, the mentioned user's screen name, and the mentioned troll's screen name.",
    "Cypher": "MATCH (t:Tweet)-[:MENTIONS]->(u:User), (t)-[:MENTIONS]->(tr:Troll) RETURN t.text AS TweetText, u.screen_name AS UserScreenName, tr.screen_name AS TrollScreenName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 450,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_450",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that contain a URL with 'twitter.com' and have more than 1000 followers. Return the troll's name, the tweet's text, and the expanded URL.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(u:URL) WHERE u.expanded_url CONTAINS 'twitter.com' AND t.followers_count > 1000 RETURN t.name AS TrollName, tw.text AS TweetText, u.expanded_url AS ExpandedURL",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 452,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_452",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of all users who have posted tweets via the source named '<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>' and have more than 1000 followers.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"https://about.twitter.com/products/tweetdeck\" rel=\"nofollow\">TweetDeck</a>' AND u.followers_count > 1000 RETURN u.name",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 456,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_456",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the number of tweets that are retweets and were posted via the source '<a href=\"http://tweets.add1.ru/add/\" rel=\"nofollow\">pourtwi</a>'.",
    "Cypher": "MATCH (t:Tweet)-[:POSTED_VIA]->(s:Source) WHERE t.retweeted = true AND s.name = '<a href=\"http://tweets.add1.ru/add/\" rel=\"nofollow\">pourtwi</a>' RETURN count(t)",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 459,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_459",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all tweets that contain both the hashtag 'latinosfortrump' and a URL, returning the tweet's text and the expanded URL.",
    "Cypher": "MATCH (t:Tweet)-[:HAS_TAG]->(h:Hashtag) WHERE h.tag = 'latinosfortrump' MATCH (t)-[:HAS_LINK]->(u:URL) RETURN t.text AS TweetText, u.expanded_url AS ExpandedURL",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 469,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_469",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of trolls who have posted tweets via the source '<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>', along with the text of those tweets.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>' RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 470,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_470",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find users who have posted tweets that mention the user with the user_key 'crazyhouse3' and also contain a URL. Return the names of these users and the expanded URLs contained in their tweets.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)-[:MENTIONS]->(m:User) WHERE m.user_key = 'crazyhouse3' MATCH (t)-[:HAS_LINK]->(url:URL) RETURN u.name AS UserName, url.expanded_url AS ExpandedURL",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 471,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_471",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the text of tweets posted by trolls from the timezone 'Pacific Time (US & Canada)' that also contain the hashtag 'latinosfortrump'.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag) WHERE t.time_zone = 'Pacific Time (US & Canada)' AND h.tag = 'latinosfortrump' RETURN tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 472,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_472",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that are retweets of tweets containing the word 'cycle'. Return the screen names of the trolls and the text of their retweets.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:RETWEETED]->(orig:Tweet) WHERE orig.text CONTAINS 'cycle' RETURN t.screen_name AS TrollScreenName, tw.text AS RetweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 473,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_473",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of all trolls who have posted tweets that have been retweeted and contain the hashtag 'education'.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:RETWEETED]->(originalTweet:Tweet), (originalTweet)-[:HAS_TAG]->(h:Hashtag) WHERE h.tag = 'education' RETURN t.name AS TrollName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 479,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_479",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the sources used to post tweets that mention the user with user_key 'brianajuarezz'. Also, return the count of such tweets for each source.",
    "Cypher": "MATCH (s:Source)<-[:POSTED_VIA]-(t:Tweet)-[:MENTIONS]->(u:User) WHERE u.user_key = 'brianajuarezz' RETURN s.name AS SourceName, COUNT(t) AS TweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 484,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_484",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of trolls who have posted tweets via the source named '<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>'. Also, return the text of those tweets.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>' RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 486,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_486",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of all trolls who have posted tweets that were retweeted, and also, the screen names of the trolls who were mentioned in those retweeted tweets.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:RETWEETED]->(rt:Tweet) OPTIONAL MATCH (rt)-[:MENTIONS]->(mentioned_troll:Troll) RETURN DISTINCT t.screen_name AS PostingTroll, COLLECT(DISTINCT mentioned_troll.screen_name) AS MentionedTrolls",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 493,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_493",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the top 3 users who have posted the most tweets via the source '<a href=\"http://twitterfeed.com\" rel=\"nofollow\">twitterfeed</a>'. Return the user's name and the number of tweets they posted through this source.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(t:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://twitterfeed.com\" rel=\"nofollow\">twitterfeed</a>' WITH u, COUNT(t) AS tweetCount ORDER BY tweetCount DESC LIMIT 3 RETURN u.name AS UserName, tweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 498,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_498",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of all trolls who have posted more than 1000 statuses and whose tweets contain the hashtag 'trolling'.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag) WHERE t.statuses_count > 1000 AND h.tag = 'trolling' RETURN t.name AS TrollName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 500,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_500",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the text of tweets that were posted via the source with name '<a href=\"http://twitter.com/download/iphone\" rel=\"nofollow\">Twitter for iPhone</a>' and also contain a URL.",
    "Cypher": "MATCH (tw:Tweet)-[:POSTED_VIA]->(s:Source), (tw)-[:HAS_LINK]->(u:URL) WHERE s.name = '<a href=\"http://twitter.com/download/iphone\" rel=\"nofollow\">Twitter for iPhone</a>' RETURN tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 506,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_506",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the text of tweets that retweet other tweets, where the original tweet contains the hashtag 'debate'.",
    "Cypher": "MATCH (t1:Tweet)-[:HAS_TAG]->(h:Hashtag), (t2:Tweet)-[:RETWEETED]->(t1) WHERE h.tag = 'debate' RETURN t2.text",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 513,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_513",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the names of all users who have posted more than one tweet that contains a URL and was posted via the source named '<a href=\"http://dlvr.it\" rel=\"nofollow\">dlvr.it</a>'.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(url:URL), (tw)-[:POSTED_VIA]->(s:Source {name: '<a href=\"http://dlvr.it\" rel=\"nofollow\">dlvr.it</a>'}) WITH u, COUNT(tw) AS tweetCount WHERE tweetCount > 1 RETURN u.name AS UserName;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 522,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_522",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of trolls who have posted tweets via the source '<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>' and also mention a user.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:POSTED_VIA]->(s:Source), (tw)-[:MENTIONS]->(u:User) WHERE s.name = '<a href=\"http://twitter.com\" rel=\"nofollow\">Twitter Web Client</a>' RETURN t.screen_name AS TrollScreenName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 526,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_526",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of trolls whose descriptions are not empty and who have posted at least one tweet that contains a URL.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:HAS_LINK]->(u:URL) WHERE t.description <> '' RETURN t.name AS TrollName",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 528,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_528",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of all users who have been mentioned in tweets posted via the source '<a href=\"http://bufferapp.com\" rel=\"nofollow\">Buffer</a>'. Also, return the text of those tweets.",
    "Cypher": "MATCH (u:User)<-[:MENTIONS]-(tw:Tweet)-[:POSTED_VIA]->(s:Source) WHERE s.name = '<a href=\"http://bufferapp.com\" rel=\"nofollow\">Buffer</a>' RETURN u.name AS UserName, tw.text AS TweetText;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 533,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_533",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the number of tweets posted by trolls with the user key 'ilovesarahrich' that mention users with the user key 'nydailynews'.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User) WHERE t.user_key = 'ilovesarahrich' AND u.user_key = 'nydailynews' RETURN count(tw) AS TweetCount;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 534,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_534",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of trolls who have posted tweets that are retweets of other tweets, and also include the text of the original retweeted tweets.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:RETWEETED]->(original:Tweet) RETURN t.screen_name AS TrollScreenName, original.text AS OriginalTweetText;",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 535,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_535",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the names of the top 3 sources that have been used to post tweets that mention the user with user_key 'lindseygrahamsc'.",
    "Cypher": "MATCH (tw:Tweet)-[:MENTIONS]->(u:User), (tw)-[:POSTED_VIA]->(s:Source) WHERE u.user_key = 'lindseygrahamsc' WITH s, COUNT(tw) AS tweetCount ORDER BY tweetCount DESC LIMIT 3 RETURN s.name AS SourceName, tweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 540,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_540",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find users who have posted tweets that contain URLs and hashtags, and whose number of followers is greater than 5000. Return the user's screen name, the tweet text, and the expanded URL.",
    "Cypher": "MATCH (u:User)-[:POSTED]->(tw:Tweet)-[:HAS_TAG]->(h:Hashtag), (tw)-[:HAS_LINK]->(url:URL) WHERE u.followers_count > 5000 RETURN u.screen_name AS UserScreenName, tw.text AS TweetText, url.expanded_url AS ExpandedURL",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 543,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_543",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Retrieve the screen names of trolls who have posted tweets that mention the user with user_key 'infowarsreports', along with the text of those tweets.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet)-[:MENTIONS]->(u:User) WHERE u.user_key = 'infowarsreports' RETURN t.screen_name AS TrollScreenName, tw.text AS TweetText",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 547,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_547",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find all trolls who have posted tweets that contain the exact text 'RT @melanieusn1979: @SooperMexican @realDonaldTrump what happened?', and return their screen names and the creation date of their accounts.",
    "Cypher": "MATCH (t:Troll)-[:POSTED]->(tw:Tweet) WHERE tw.text = 'RT @melanieusn1979: @SooperMexican @realDonaldTrump what happened?' RETURN t.screen_name AS TrollScreenName, t.created_at AS TrollCreationDate",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 549,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_549",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  },
  {
    "NL Question": "Find the users who have been mentioned in tweets that were posted via '<a href=\"http://twitter.com/download/iphone\" rel=\"nofollow\">Twitter for iPhone</a>'. Return the user's screen name and the count of tweets where they were mentioned.",
    "Cypher": "MATCH (s:Source {name: '<a href=\"http://twitter.com/download/iphone\" rel=\"nofollow\">Twitter for iPhone</a>'})<-[:POSTED_VIA]-(tw:Tweet)-[:MENTIONS]->(u:User) WITH u.screen_name AS UserScreenName, COUNT(tw) AS TweetCount ORDER BY TweetCount DESC RETURN UserScreenName, TweetCount",
    "source_dataset": "twitter_trolls",
    "source_chunk": "data_3_2_2_6",
    "original_file": "Complex_Retrieval.json",
    "original_index": 555,
    "unique_id": "twitter_trolls_data_3_2_2_6_Complex_Retrieval_555",
    "pipeline_stage": "PASSED_ALL",
    "schema_validation": "✅ Query is valid according to schema!",
    "runtime_validation": "Passed",
    "neo4j_runtime_validation": "No runtime errors.",
    "neo4j_runtime_passed": 1,
    "neo4j_result_validation": "Results returned successfully.",
    "neo4j_result_passed": 1,
    "content_validation": "Results contain non-null, non-zero values.",
    "content_passed": 1,
    "value_validation": "✅ All values in Cypher are consistent with the NL question."
  }
]