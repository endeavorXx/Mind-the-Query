Date -> 18/01/2025

v0

Your task is to generate {num_questions} questions that are directly related to a specific graph schema in Neo4j. Each question should target distinct aspects of the schema, such as relationships between nodes, properties of nodes, or characteristics of node types. 
Imagine you are a user at a company that needs to present all the types of questions that the graph can answer.
You have to be very diligent at your job.
The goal of these questions is to create a dataset for training AI models to convert natural language queries into Cypher queries effectively.
Task - 
- Generate {num_questions} Questions and corresponding cypher statement from the following graph schema : {schema}.\n 
- Generate logical natural language questions based on the schema, avoid ambiguous question which can be interpreted in multiple ways or does not have a straightforward answer. For example, avoid asking, "What is related to this?" without specifying the node type or relationship. 
- The questions should be diverse and vary in increasing complexity.
- These questions should target a specific query type category {category} which has following description {query_type}. Here are some examples for the the mentioned query type {in_context}.
- It is vital that the database contains information that can answer the question. Don't use any not provided node and relationship values. \n provided node values : {node_values} \n provided relationship values : {rels_values}.
- Be concrete with attributes of nodes and relationships, their spellings and writing style like camel case or any other while forming natural language question and corresponding cypher.
- Be concrete with values of nodes and relationships, their spellings and writing style like camel case or any other while forming natural language question and corresponding cypher.
- Always keep in mind the data type of attributes for the nodes and relationship. For example for simple aggregation or complex aggregation type queries, It makes no sense to ask for average of Descriptions which has "STRING" datatype.
- for every question you have to provide a reason why that question belongs to that specific query type. Therefore you have to give {num_questions} questions and their reasoning why it belong to that particular category of query type. 

Also, do not ask questions that there is no way to answer based on the schema or provided example values. 
Find good natural language questions that will test the capabilities of graph answering.
put all the questions in a list, each question with reasoning and it's cypher with reasoning must be enclosed in a dictionary !!
[
    {
    "NL Question": # your_question,
    "Reason for NL": # Provide reason why it is correct logically, 
    "Cypher": # Cypher statement corresponding to that question, 
    "Reason for cypher": # Provide reason why your cypher is correct logically for the natural language question
    }, 
    {
    "NL Question": # your_question,
    "Reason for NL": # Provide reason why it is correct logically, 
    "Cypher": # Cypher statement corresponding to that question, 
    "Reason for cypher": # Provide reason why your cypher is correct logically for the natural language question
    }, 
    so on...
]
Just write the json file !!

V1.1
================ CHANGE =========================
1. Added point number 6, letter by letter (point). 
=================================================
Your task is to generate {num_questions} questions that are directly related to a specific graph schema in Neo4j. Each question should target distinct aspects of the schema, such as relationships between nodes, properties of nodes, or characteristics of node types. 
Imagine you are a user at a company that needs to present all the types of questions that the graph can answer.
You have to be very diligent at your job.
The goal of these questions is to create a dataset for training AI models to convert natural language queries into Cypher queries effectively.
Task - 
- Generate {num_questions} Questions and corresponding cypher statement from the following graph schema : {schema}.\n 
- Generate logical natural language questions based on the schema, avoid ambiguous question which can be interpreted in multiple ways or does not have a straightforward answer. For example, avoid asking, "What is related to this?" without specifying the node type or relationship. 
- The questions should be diverse and vary in increasing complexity.
- These questions should target a specific query type category {category} which has following description {query_type}. Here are some examples for the the mentioned query type {in_context}.
- It is vital that the database contains information that can answer the question. Don't use any not provided node and relationship values. \n provided node values : {node_values} \n provided relationship values : {rels_values}. 
- while making cypher and natural language questions, Be careful while inducing node values and relationship values. They should match letter by letter. since, they will be directly used in the query.
- Always keep in mind the data type of attributes for the nodes and relationship. For example for simple aggregation or complex aggregation type queries, It makes no sense to ask for average of Descriptions which has "STRING" datatype.
- for every question you have to provide a reason why that question belongs to that specific query type. Therefore you have to give {num_questions} questions and their reasoning why it belong to that particular category of query type. 

Also, do not ask questions that there is no way to answer based on the schema or provided example values. 
Find good natural language questions that will test the capabilities of graph answering.
put all the questions in a list, each question with reasoning and it's cypher with reasoning must be enclosed in a dictionary !!
[
{{
"NL Question": # your_question,
"Reason for NL": # Provide reason why it is correct logically, 
"Cypher": # Cypher statement corresponding to that question, 
"Reason for cypher": # Provide reason why your cypher is correct logically for the natural language question
}}, 
{{
"NL Question": # your_question,
"Reason for NL": # Provide reason why it is correct logically, 
"Cypher": # Cypher statement corresponding to that question, 
"Reason for cypher": # Provide reason why your cypher is correct logically for the natural language question
}}, 
so on...
]
Just write the json file !!


p1.2
====================== CHANGES =======================
1. Added cypher in-context samples
2. Added point 7, 8 for consider letter by letter word matching for node properties and relationship properties.
======================================================

Your task is to generate {num_questions} questions that are directly related to a specific graph schema in Neo4j. Each question should target distinct aspects of the schema, such as relationships between nodes, properties of nodes, or characteristics of node types. 
Imagine you are a user at a company that needs to present all the types of questions that the graph can answer.
You have to be very diligent at your job.
The goal of these questions is to create a dataset for training AI models to convert natural language queries into Cypher queries effectively.
Task - 
- Generate {num_questions} Questions and corresponding cypher statement from the following graph schema : {schema}.\n 
- Generate logical natural language questions based on the schema, avoid ambiguous question which can be interpreted in multiple ways or does not have a straightforward answer. For example, avoid asking, "What is related to this?" without specifying the node type or relationship. 
- The questions should be diverse and vary in increasing complexity.
- These questions should target a specific query type category {category} which has following description {query_type}. Here are some examples for the the mentioned query type {in_context}.
- It is vital that the database contains information that can answer the question. Don't use any not provided node and relationship values. \n provided node values : {node_values} \n provided relationship values : {rels_values}. 
- while making cypher and natural language questions, Be careful while inducing node values and relationship values. They should match letter by letter. since, they will be directly used in the query.
- while making cypher and natural language questions, Be careful while using Node and relationship names. They should match letter by letter.
- while making cypher and natural language questions, Be careful while using Node and relationship properties. They should match letter by letter.
- Always keep in mind the data type of attributes for the nodes and relationship. For example for simple aggregation or complex aggregation type queries, It makes no sense to ask for average of Descriptions which has "STRING" datatype.
- for every question you have to provide a reason why that question belongs to that specific query type. Therefore you have to give {num_questions} questions and their reasoning why it belong to that particular category of query type. 

Also, do not ask questions that there is no way to answer based on the schema or provided example values. 
Find good natural language questions that will test the capabilities of graph answering.
put all the questions in a list, each question with reasoning and it's cypher with reasoning must be enclosed in a dictionary !!
[
{{
"NL Question": # your_question,
"Reason for NL": # Provide reason why it is correct logically, 
"Cypher": # Cypher statement corresponding to that question, 
"Reason for cypher": # Provide reason why your cypher is correct logically for the natural language question
}}, 
{{
"NL Question": # your_question,
"Reason for NL": # Provide reason why it is correct logically, 
"Cypher": # Cypher statement corresponding to that question, 
"Reason for cypher": # Provide reason why your cypher is correct logically for the natural language question
}}, 
so on...
]
Just write the json file !!

p1.3
=================== CHANGES ============================
1. added point 4, to have concrete natural language question to retrieve specific information.
========================================================

Your task is to generate {num_questions} questions that are directly related to a specific graph schema in Neo4j. Each question should target distinct aspects of the schema, such as relationships between nodes, properties of nodes, or characteristics of node types. 
Imagine you are a user at a company that needs to present all the types of questions that the graph can answer.
You have to be very diligent at your job.
The goal of these questions is to create a dataset for training AI models to convert natural language queries into Cypher queries effectively.
Task - 
- Generate {num_questions} Questions and corresponding cypher statement from the following graph schema : {schema}.\n 
- Generate logical natural language questions based on the schema, avoid ambiguous question which can be interpreted in multiple ways or does not have a straightforward answer. For example, avoid asking, "What is related to this?" without specifying the node type or relationship. 
- The questions should be diverse and vary in increasing complexity.
- 
- These questions should target a specific query type category {category} which has following description {query_type}. Here are some examples for the the mentioned query type {in_context}.
- It is vital that the database contains information that can answer the question. Don't use any not provided node and relationship values. \n provided node values : {node_values} \n provided relationship values : {rels_values}. 
- while making cypher and natural language questions, Be careful while inducing node values and relationship values. They should match letter by letter. since, they will be directly used in the query.
- while making cypher and natural language questions, Be careful while using Node and relationship names. They should match letter by letter.
- while making cypher and natural language questions, Be careful while using Node and relationship properties. They should match letter by letter.
- Always keep in mind the data type of attributes for the nodes and relationship. For example for simple aggregation or complex aggregation type queries, It makes no sense to ask for average of Descriptions which has "STRING" datatype.
- for every question you have to provide a reason why that question belongs to that specific query type. Therefore you have to give {num_questions} questions and their reasoning why it belong to that particular category of query type. 

Also, do not ask questions that there is no way to answer based on the schema or provided example values. 
Find good natural language questions that will test the capabilities of graph answering.
put all the questions in a list, each question with reasoning and it's cypher with reasoning must be enclosed in a dictionary !!
[
{{
"NL Question": # your_question,
"Reason for NL": # Provide reason why it is correct logically, 
"Cypher": # Cypher statement corresponding to that question, 
"Reason for cypher": # Provide reason why your cypher is correct logically for the natural language question
}}, 
{{
"NL Question": # your_question,
"Reason for NL": # Provide reason why it is correct logically, 
"Cypher": # Cypher statement corresponding to that question, 
"Reason for cypher": # Provide reason why your cypher is correct logically for the natural language question
}}, 
so on...
]
Just write the json file !!

p -> 2.1
===================== CHANGES ==================
1. Made necessary changes 
a. Changed Schema, corrected some fields
b. Changed Spelling "primarySubstanbce" to "primarySubstance"
================================================

Your task is to generate {num_questions} questions that are directly related to a specific graph schema in Neo4j. Each question should target distinct aspects of the schema, such as relationships between nodes, properties of nodes, or characteristics of node types. 
Imagine you are a user at a company that needs to present all the types of questions that the graph can answer.
You have to be very diligent at your job.
The goal of these questions is to create a dataset for training AI models to convert natural language queries into Cypher queries effectively.
Task - 
- Generate {num_questions} Questions and corresponding cypher statement from the following graph schema : {schema}.\n 
- Generate logical natural language questions based on the schema, avoid ambiguous question which can be interpreted in multiple ways or does not have a straightforward answer. For example, avoid asking, "What is related to this?" without specifying the node type or relationship. 
- The questions should be diverse and vary in increasing complexity.
- These questions should target a specific query type category {category} which has following description {query_type}. Here are some examples for the the mentioned query type {in_context}.
- It is vital that the database contains information that can answer the question. Don't use any not provided node and relationship values. \n provided node values : {node_values} \n provided relationship values : {rels_values}. 
- while making cypher and natural language questions, Be careful while inducing node values and relationship values. They should match letter by letter. since, they will be directly used in the query.
- while making cypher and natural language questions, Be careful while using Node and relationship names. They should match letter by letter.
- while making cypher and natural language questions, Be careful while using Node and relationship properties. They should match letter by letter.
- Always keep in mind the data type of attributes for the nodes and relationship. For example for simple aggregation or complex aggregation type queries, It makes no sense to ask for average of Descriptions which has "STRING" datatype.
- for every question you have to provide a reason why that question belongs to that specific query type. Therefore you have to give {num_questions} questions and their reasoning why it belong to that particular category of query type. 

Also, do not ask questions that there is no way to answer based on the schema or provided example values. 
Find good natural language questions that will test the capabilities of graph answering.
put all the questions in a list, each question with reasoning and it's cypher with reasoning must be enclosed in a dictionary !!
[
{{
"NL Question": # your_question,
"Reason for NL": # Provide reason why it is correct logically, 
"Cypher": # Cypher statement corresponding to that question, 
"Reason for cypher": # Provide reason why your cypher is correct logically for the natural language question
}}, 
{{
"NL Question": # your_question,
"Reason for NL": # Provide reason why it is correct logically, 
"Cypher": # Cypher statement corresponding to that question, 
"Reason for cypher": # Provide reason why your cypher is correct logically for the natural language question
}}, 
so on...
]
Just write the json file !!


p -> 2.2
===================== CHANGES ==================

1. Added point to target more nodes and relationship for generation of diverse datasets, last point with "-".

Effect -> not_working, ended up getting same results, even hit-ratio dropped 
================================================


Your task is to generate {num_questions} questions that are directly related to a specific graph schema in Neo4j. Each question should target distinct aspects of the schema, such as relationships between nodes, properties of nodes, or characteristics of node types. 
Imagine you are a user at a company that needs to present all the types of questions that the graph can answer.
You have to be very diligent at your job.
The goal of these questions is to create a dataset for training AI models to convert natural language queries into Cypher queries effectively.
Task - 
- Generate {num_questions} Questions and corresponding cypher statement from the following graph schema : {schema}.\n 
- Generate logical natural language questions based on the schema, avoid ambiguous question which can be interpreted in multiple ways or does not have a straightforward answer. For example, avoid asking, "What is related to this?" without specifying the node type or relationship. 
- The questions should be diverse and vary in increasing complexity.
- These questions should target a specific query type category {category} which has following description {query_type}. Here are some examples for the the mentioned query type {in_context}.
- It is vital that the database contains information that can answer the question. Don't use any not provided node and relationship values. \n provided node values : {node_values} \n provided relationship values : {rels_values}. 
- while making cypher and natural language questions, Be careful while inducing node values and relationship values. They should match letter by letter. since, they will be directly used in the query.
- while making cypher and natural language questions, Be careful while using Node and relationship names. They should match letter by letter.
- while making cypher and natural language questions, Be careful while using Node and relationship properties. They should match letter by letter.
- Always keep in mind the data type of attributes for the nodes and relationship. For example for simple aggregation or complex aggregation type queries, It makes no sense to ask for average of Descriptions which has "STRING" datatype.
- for every question you have to provide a reason why that question belongs to that specific query type. Therefore you have to give {num_questions} questions and their reasoning why it belong to that particular category of query type. 
- Out of {num_questions}, Each Retrieval based should target to retrieve information from different node and relationship

Also, do not ask questions that there is no way to answer based on the schema or provided example values. 
Find good natural language questions that will test the capabilities of graph answering.
put all the questions in a list, each question with reasoning and it's cypher with reasoning must be enclosed in a dictionary !!
[
{{
"NL Question": # your_question,
"Reason for NL": # Provide reason why it is correct logically, 
"Cypher": # Cypher statement corresponding to that question, 
"Reason for cypher": # Provide reason why your cypher is correct logically for the natural language question
}}, 
{{
"NL Question": # your_question,
"Reason for NL": # Provide reason why it is correct logically, 
"Cypher": # Cypher statement corresponding to that question, 
"Reason for cypher": # Provide reason why your cypher is correct logically for the natural language question
}}, 
so on...
]
Just write the json file !!


p -> 2.3
===================== CHANGES ==================
Change of prompt 2.2 
a. additional information while curating queries with dates
================================================

Your task is to generate {num_questions} questions that are directly related to a specific graph schema in Neo4j. Each question should target distinct aspects of the schema, such as relationships between nodes, properties of nodes, or characteristics of node types. 
Imagine you are a user at a company that needs to present all the types of questions that the graph can answer.
You have to be very diligent at your job.
The goal of these questions is to create a dataset for training AI models to convert natural language queries into Cypher queries effectively.
Task - 
- Generate {num_questions} Questions and corresponding cypher statement from the following graph schema : {schema}.\n 
- Generate logical natural language questions based on the schema, avoid ambiguous question which can be interpreted in multiple ways or does not have a straightforward answer. For example, avoid asking, "What is related to this?" without specifying the node type or relationship. 
- The questions should be diverse and vary in increasing complexity.
- These questions should target a specific query type category {category} which has following description {query_type}. Here are some examples for the the mentioned query type {in_context}.
- It is vital that the database contains information that can answer the question. Don't use any not provided node and relationship values. \n provided node values : {node_values} \n provided relationship values : {rels_values}. 
- while making cypher and natural language questions, Be careful while inducing node values and relationship values. They should match letter by letter. since, they will be directly used in the query.
- while making cypher and natural language questions, Be careful while using Node and relationship names. They should match letter by letter.
- while making cypher and natural language questions, Be careful while using Node and relationship properties. They should match letter by letter.
- Always keep in mind the data type of attributes for the nodes and relationship. For example for simple aggregation or complex aggregation type queries, It makes no sense to ask for average of Descriptions which has "STRING" datatype.
- for every question you have to provide a reason why that question belongs to that specific query type. Therefore you have to give {num_questions} questions and their reasoning why it belong to that particular category of query type. 
- While making queries involving dates, Mae sure to follow these formats provided in the example -
(i) date(dob) = date("1981-06-20") while comparing dates
(ii) use player.dob.year to extract year from the date and not year(player.dob), similarly use player.dob.month and player.dob.day to extract month and day.

Also, do not ask questions that there is no way to answer based on the schema or provided example values. 
Find good natural language questions that will test the capabilities of graph answering.
put all the questions in a list, each question with reasoning and it's cypher with reasoning must be enclosed in a dictionary !!
[
{{
"NL Question": # your_question,
"Reason for NL": # Provide reason why it is correct logically, 
"Cypher": # Cypher statement corresponding to that question, 
"Reason for cypher": # Provide reason why your cypher is correct logically for the natural language question
}}, 
{{
"NL Question": # your_question,
"Reason for NL": # Provide reason why it is correct logically, 
"Cypher": # Cypher statement corresponding to that question, 
"Reason for cypher": # Provide reason why your cypher is correct logically for the natural language question
}}, 
so on...
]
Just write the json file !!


p -> 2.4
================== CHANGES ==========================
change to prompt 2.3 
1. Added condition that for aggregation, you can not use aggregator inside a aggregator
========================================================

Your task is to generate {num_questions} questions that are directly related to a specific graph schema in Neo4j. Each question should target distinct aspects of the schema, such as relationships between nodes, properties of nodes, or characteristics of node types. 
Imagine you are a user at a company that needs to present all the types of questions that the graph can answer.
You have to be very diligent at your job.
The goal of these questions is to create a dataset for training AI models to convert natural language queries into Cypher queries effectively.
Task - 
- Generate {num_questions} Questions and corresponding cypher statement from the following graph schema : {schema}.\n 
- Generate logical natural language questions based on the schema, avoid ambiguous question which can be interpreted in multiple ways or does not have a straightforward answer. For example, avoid asking, "What is related to this?" without specifying the node type or relationship. 
- The questions should be diverse and vary in increasing complexity.
- These questions should target a specific query type category {category} which has following description {query_type}. Here are some examples for the the mentioned query type {in_context}.
- It is vital that the database contains information that can answer the question. Don't use any not provided node and relationship values. \n provided node values : {node_values} \n provided relationship values : {rels_values}. 
- while making cypher and natural language questions, Be careful while inducing node values and relationship values. They should match letter by letter. since, they will be directly used in the query.
- while making cypher and natural language questions, Be careful while using Node and relationship names. They should match letter by letter.
- while making cypher and natural language questions, Be careful while using Node and relationship properties. They should match letter by letter.
- Always keep in mind the data type of attributes for the nodes and relationship. For example for simple aggregation or complex aggregation type queries, It makes no sense to ask for average of Descriptions which has "STRING" datatype.
- for every question you have to provide a reason why that question belongs to that specific query type. Therefore you have to give {num_questions} questions and their reasoning why it belong to that particular category of query type. 
- Note that while constructing cyphers, you can not use aggregator inside an aggregator, for example AVG(COUNT()), it's not valid.
- While making queries involving dates, Mae sure to follow these formats provided in the example -
(i) date(dob) = date("1981-06-20") while comparing dates
(ii) use player.dob.year to extract year from the date and not year(player.dob), similarly use player.dob.month and player.dob.day to extract month and day.

Also, do not ask questions that there is no way to answer based on the schema or provided example values. 
Find good natural language questions that will test the capabilities of graph answering.
put all the questions in a list, each question with reasoning and it's cypher with reasoning must be enclosed in a dictionary !!
[
{{
"NL Question": # your_question,
"Reason for NL": # Provide reason why it is correct logically, 
"Cypher": # Cypher statement corresponding to that question, 
"Reason for cypher": # Provide reason why your cypher is correct logically for the natural language question
}}, 
{{
"NL Question": # your_question,
"Reason for NL": # Provide reason why it is correct logically, 
"Cypher": # Cypher statement corresponding to that question, 
"Reason for cypher": # Provide reason why your cypher is correct logically for the natural language question
}}, 
so on...
]
Just write the json file !!

p->2.5
================== CHANGES ==========================
1. Generalization in describing date formats 
=====================================================
Your task is to generate {num_questions} questions that are directly related to a specific graph schema in Neo4j. Each question should target distinct aspects of the schema, such as relationships between nodes, properties of nodes, or characteristics of node types. 
Imagine you are a user at a company that needs to present all the types of questions that the graph can answer.
You have to be very diligent at your job.
The goal of these questions is to create a dataset for training AI models to convert natural language queries into Cypher queries effectively.
Task - 
- Generate {num_questions} Questions and corresponding cypher statement from the following graph schema : {schema}.\n 
- Generate logical natural language questions based on the schema, avoid ambiguous question which can be interpreted in multiple ways or does not have a straightforward answer. For example, avoid asking, "What is related to this?" without specifying the node type or relationship. 
- The questions should be diverse and vary in increasing complexity.
- These questions should target a specific query type category {category} which has following description {query_type}. Here are some examples for the the mentioned query type {in_context}.
- It is vital that the database contains information that can answer the question. Don't use any not provided node and relationship values. \n provided node values : {node_values} \n provided relationship values : {rels_values}. 
- while making cypher and natural language questions, Be careful while inducing node values and relationship values. They should match letter by letter. since, they will be directly used in the query.
- while making cypher and natural language questions, Be careful while using Node and relationship names. They should match letter by letter.
- while making cypher and natural language questions, Be careful while using Node and relationship properties. They should match letter by letter.
- Always keep in mind the data type of attributes for the nodes and relationship. For example for simple aggregation or complex aggregation type queries, It makes no sense to ask for average of Descriptions which has "STRING" datatype.
- for every question you have to provide a reason why that question belongs to that specific query type. Therefore you have to give {num_questions} questions and their reasoning why it belong to that particular category of query type. 
- Note that while constructing cyphers, you can not use aggregator inside an aggregator, for example AVG(COUNT()), it's not valid.
- While making queries involving dates, Mae sure to follow these formats and principles provided in the example -
(i) When comparing dates, convert the date property using a generic date string format (e.g., date(dob) = date("YYYY-MM-DD")).
(ii) To extract date components, use the dot notation (e.g., player.dob.year, player.dob.month, player.dob.day) instead of using functions like year(player.dob).
Also, do not ask questions that there is no way to answer based on the schema or provided example values. 
Find good natural language questions that will test the capabilities of graph answering.
put all the questions in a list, each question with reasoning and it's cypher with reasoning must be enclosed in a dictionary !!
[
{{
"NL Question": # your_question,
"Reason for NL": # Provide reason why it is correct logically, 
"Cypher": # Cypher statement corresponding to that question, 
"Reason for cypher": # Provide reason why your cypher is correct logically for the natural language question
}}, 
{{
"NL Question": # your_question,
"Reason for NL": # Provide reason why it is correct logically, 
"Cypher": # Cypher statement corresponding to that question, 
"Reason for cypher": # Provide reason why your cypher is correct logically for the natural language question
}}, 
so on...
]
Just write the json file !!
